#   aux_funcs.py
#   Auxiliary functions and data structures
#   Author: Duarte Matias
#   Last Modified: 15/10/2022 
#

from datetime import datetime
import threading
import logging
from consolemenu import SelectionMenu
from scapy.sendrecv import send, sendp
from scapy.layers.inet import IP
from scapy.layers.l2 import Ether
from scapy.packet import Packet
from scapy.utils import PcapWriter
from scapy.fields import *
from scapy.contrib.ospf import _OSPF_Router_LSA_types
from scapy.all import get_if_hwaddr, get_if_addr
from pathlib import Path
from enum import Enum

######
# VARS
######
EXIT_SIGNAL = threading.Event()     # Exit signal for threads when KeyboardInterrupt occurs


#####################
#   send_l3_single()
#   Sends a single packet that doesn't contain any L2 headers
#####################
def send_l3_single(args):
    pkt = args['pkt']
    iface = args['iface']

    # Fix missing source IP if needed
    if pkt[IP].src == '0.0.0.0':
        pkt[IP].src = get_if_addr(iface)

    # Check for multicast IP
    if pkt[IP].dst.split('.')[0] == '224':
        # Get the mac address for this multicast ip
        # Separate into octets
        octets = pkt[IP].dst.split('.')

        # Format the octets
        oct_2 = int(octets[1]) & 127
        oct_3 = int(octets[2])
        oct_4 = int(octets[3])

        # Create the mac string
        mcast_mac = f"01:00:5e:{format(oct_2, '02x')}:{format(oct_3,'02x')}:{format(oct_4,'02x')}"

        # Add mac to ether layer
        pkt = Ether(dst=mcast_mac, src=get_if_hwaddr(iface))/pkt

        # Send the packet with layer 2 function
        res = sendp(pkt, iface=iface)

    else:
        # Send the packet with layer 3 function
        res = send(pkt, iface=iface)

    return res

#####################
#   send_l3_loop()
#   Repeatedly sends packets that don't contain any L2 headers
#####################
def send_l3_loop(args):
    pkt = args['pkt']
    iface = args['iface']

    # Get send interval from params
    if 'interval' in args.keys():
        interval = int(args['interval'])
    else:
        interval = 0    # Else interval is 0

    # Fix missing source IP if needed
    if pkt[IP].src == '0.0.0.0':
        pkt[IP].src = get_if_addr(iface)

    # Check for multicast IP (first octet in range 224..239)
    if pkt[IP].dst.split('.')[0] in [str(x) for x in range(224, 240)]:
        # Get the mac address for this multicast ip
        # Separate into octets
        octets = pkt[IP].dst.split('.')

        # Format the octets
        oct_2 = int(octets[1]) & 127
        oct_3 = int(octets[2])
        oct_4 = int(octets[3])

        # Create the mac string
        mcast_mac = f"01:00:5e:{format(oct_2, '02x')}:{format(oct_3,'02x')}:{format(oct_4,'02x')}"

        # Add mac to ether layer
        pkt = Ether(dst=mcast_mac, src=get_if_hwaddr(iface))/pkt

        while not EXIT_SIGNAL.is_set():
            res = sendp(pkt, iface=iface)
            time.sleep(interval)
        else:
            logging.debug("Stopping attack...")
            return res

    # Unicast IP
    else:
        while not EXIT_SIGNAL.is_set():
            res = send(pkt, iface=iface)
            time.sleep(interval)
        else:
            logging.debug("Stopping attack...")
            return res
    

#####################
#   send_l2_single
#   Sends a single packet that contains L2 Headers
#####################
def send_l2_single(args):
    pkt = args['pkt']
    iface = args['iface']

    res = sendp(pkt, iface=iface)

    return res

#####################
#   send_l2_loop
#   Repeatedly sends packets that contain L2 headers
#####################
def send_l2_loop(args: dict):
    pkt = args['pkt']
    iface = args['iface']

    # Check for send interval
    if 'interval' in args.keys():
        interval = int(args['interval'])
    else:
        interval = 0

    while not EXIT_SIGNAL.is_set():
        res = sendp(pkt, iface=iface, inter = interval)
        time.sleep(interval)
    else:
        logging.debug("Stopping attack...")
        return res


#####################
# Patched OSPF class to support TOS fields. WIP
#####################
class OSPF_Link(Packet):
    name = "OSPF Link"
    fields_desc = [IPField("id", "192.168.0.0"),
                   IPField("data", "255.255.255.0"),
                   ByteEnumField("type", 3, _OSPF_Router_LSA_types),
                   ByteField("toscount", 0),
                   ShortField("metric", 10),
                   
                   ConditionalField(ByteField("tos", 0), lambda pkt: pkt.toscount == 1),
                   ConditionalField(ByteField("reserved", 0), lambda pkt: pkt.toscount == 1),  # noqa: E501
                   ConditionalField(ShortField("tosmetric", 0), lambda pkt: pkt.toscount == 1)]  # noqa: E501

    def extract_padding(self, s):
        return "", s

#####################
# file_selector()
# Prompt the user to select a file from the supplied directory
# Returns a file, or None if the user exits selection
#####################
def file_selector(base_path):
    bp = Path(base_path)
    while True:
        p_list = [x for x in bp.iterdir()]                                          # List all files in the directory
        p_select_nr = SelectionMenu.get_selection([x.parts[-1] for x in p_list])    # Prompt the user for a selection (only shows file/directory name, not full path)
        if p_select_nr == len(p_list):                                              # Check if user selects 'exit'
            return None
        p_select = p_list[p_select_nr]                                              # Get the selection from option number

        # Check if user selected directory or file
        if p_select.is_file():  # If file, return
            return p_select
        else:   # If directory, enter and prompt again
            bp =  p_select
        

#####################
# Enum for attack types
#####################
class attack_type(Enum):
    DoS = "DoS"
    RoutePoisoning = "Route Poisoning"
    NetworkScan = "Network Scan"
    Test = "Ping Test"
    Periodic = "Periodic"
    Wrapper = "Wrapper"
    SingleUse = "Single Use"
    MitM = "Man-in-the-Middle"

#####################
# Enum for attack categories
#####################
class attack_cat(Enum):
    Attack = "Attack"
    Middleware = "Middleware"

#####################
# Enum for attack layers
#####################
class attack_layer(Enum):
    L2 = "L2"
    L3_OSPF = "L3 - OSPF"
    L3_BGP = "L3 - BGP"
    L3_RIP = "L3 - RIP"
    L4 = "L4"

#####################
# type_wrapper()
# decorator function to assign various auxiliary values to the decorated function
#####################
def type_wrapper(name: str, type: attack_type, category: attack_cat, layer: attack_layer, arg_list: list):
    def _type_wrapper(func):
        func.type = type
        func.name = name
        func.category = category
        func.layer = layer
        func.arg_list = arg_list

        return func
    return _type_wrapper


####################
# pcap_dump()
# dumps a packet list to a .pcap file in the /captures folder
# filename is the bname + creation date and time
####################
def pcap_dump(plist, bname):
    # Open writer
    pcap = PcapWriter(filename=f"/captures/{bname}-{datetime.now().strftime('%d-%m-%Y-%H%M%S')}.pcap")

    # Dump the packets
    pcap.write(plist)

    # Close the file
    pcap.close()

