import argparse
from itertools import chain
import netifaces
import importlib.util
import functools
import operator
from consolemenu import *
from consolemenu.items import *
from pathlib import Path
import sys
from os import getcwd
from inspect import getmembers, isfunction
from bin.libs.import_funcs import import_bgp_confs
from libs.import_funcs import import_ospf_lsa
from libs.aux_funcs import file_selector, attack_cat, attack_layer, attack_type
import logging

#Constants/Vars

descString = 'A python network pentesting tool'
confFilePath=''
attack_list = []
attack_chain = []
attacks_categories = []
attacks_layers = []
attacks_types = []
module_list = []
module_names = []
module_path = Path(getcwd()+"/bin/modules")
conf_base_path = getcwd() + '/bin/conf-examples'
attack_interface = ''
args = {}

def setupVars():

    # Configure Log file
    logging.basicConfig(filename=getcwd()+'/bin/debug.log', filemode='a', level=logging.DEBUG)
    logging.debug("Initalizing...")

    #TODO setup importing settings from .yml  or .json file

    # List all modules to import
    module_path_list = list(module_path.glob("**/*.py"))
    logging.debug("Module listing finished")

    # Import all modules
    logging.debug("Starting module import")
    for f in module_path_list:
        f_name = str(f).rstrip(".py").replace("/",".").replace("\\",".")
        spec = importlib.util.spec_from_file_location(f_name, str(f))
        module = importlib.util.module_from_spec(spec)
        sys.modules[f_name] = module
        module_names.append(f_name)
        spec.loader.exec_module(module)
        module_list.append(module)
        logging.debug(f"Successfully loaded module: {f_name}")

    logging.debug("Finished loading modules")

    # Function listing
    logging.debug("Listing available functions")
    global attack_list 
    for m in module_list:
        attack_list.append(getmembers(m, isfunction))
    attack_list = functools.reduce(operator.iconcat, attack_list)
    attack_list = list(filter(lambda x: x[1].__module__ in module_names and x[0][0] != "_", attack_list))
    logging.debug("Function listing complete")
    logging.debug("Finished variable intialization")

    return


def showChain():
    for a in attack_chain:
        print(a)
    input("Press any key to continue...")
    return

def listInterfaces():
    return netifaces.interfaces()

def selectInterface():
    global args

    iface_lst = listInterfaces()

    iface_sel = SelectionMenu.get_selection(iface_lst)

    args['iface'] = iface_lst[iface_sel]

def listAttacksAsString():
    return list([f.__name__ for f in attack_list])

def runChain():

    #TODO verify chain integrity

    global args

    for action in attack_chain:

        # Get parameters
        params = action[1].arg_list
        for param in params:
            if param not in args.keys():
                args[param] = input("Value for " + param + " >>> ")

        if action[1].category == "middleware":
            if action[1].type == "periodic":
                # TODO add thread with timer for function
                pass
            elif action[1].type == "single use":
                # Execute the function
                action[1](args)
            elif action[1].type == "wrapper":
                # Execute function and update args
                args = action[1](args)
        elif action[1].category in ("attack", "Attack"):
            # TODO send the packet
            if action[1].type == "MitM":
                action[1](args)
            elif action[1].type == "DoS":
                action[1](args)
            elif action[1].type == "Route Poisoning":
                action[1](args)
            pass
        else:
            print("Unknown item category")

    pass

def parser():

    # Create the argument parser
    parser = argparse.ArgumentParser(description=descString)

    # Add arguments to the parser
    # Debug/testing mode
    parser.add_argument('--test','-t', action='store-true', help="Run in test mode, with reduced timeouts and verbose output")
    
    
    # Config file
    #parser.add_argument('--conf-file', action='store')

    # Verbose configuration
    #parser.add_argument('--verbose', '-v', action='count', default = 0, help='configure verbose level')

    # List available interfaces and exit
    parser.add_argument('--list-interfaces', action='store-true', help='list available interfaces and exit')

    # Create subparser for headless and normal modes
    #subparsers = parser.add_subparsers(help='sub-command help')

    # Normal mode parser
    #normal_parser = subparsers.add_parser('cli', help='cli help')

    # Headless mode parser
    #headless_parser = subparsers.add_parser('headless', help='headless help')

    # Function choice
    #headless_parser.add_argument('--attack', '-a', choices=attack_list)

    # Interface choice
    #headless_parser.add_argument('--interface', '-i', choices=listInterfaces(), help='select interface to utilize')

    # Arg list for each attack
    #headless_parser.add_argument('args', nargs='+', help="additional arguments for the selected attack")

    ns = parser.parse_args()

    if ns['list-interfaces'] == True:
        print(listInterfaces())
        exit(0)

    global TEST
    TEST = False

    if ns['test'] == True:
        print("Running in test mode...")
        TEST = True

def addItemToChain():

    # Select Category, i.e: middlewares, attacks
    attacks_categories_str = [m.value for n,m in attack_cat.__members__.items()]
    category_selection = SelectionMenu.get_selection(attacks_categories_str)

    if category_selection == len(attacks_categories_str):
        return

    # Select layer
    attacks_layers_str = [m.value for n,m in attack_layer.__members__.items()]
    layer_selection = SelectionMenu.get_selection(attacks_layers_str)

    if layer_selection == len(attacks_layers_str):
        return

    # Select type, i.e: MitM, DoS, ...
    attacks_types_str = [m.value for n,m in attack_type.__members__.items()]
    type_selection = SelectionMenu.get_selection(attacks_types_str)

    if type_selection == len(attacks_types_str):
        return

    # Filter attacks list based on selection
    atk_lst = list(filter(lambda x: x[1].layer == attack_layer(attacks_layers_str[layer_selection]) and \
                                    x[1].type == attack_type(attacks_layers_str[type_selection]) and \
                                    x[1].category == attack_cat(attacks_categories_str[category_selection]), attack_list))

    function_selection = SelectionMenu.get_selection(list([f[1].name for f in atk_lst]))

    if function_selection == len(atk_lst):
        return

    # Append function to current chain
    # TODO Verify if selection is valid
    attack_chain.append(atk_lst[function_selection])
    return   

def removeFromChain():

    item_selection = SelectionMenu.get_selection(attack_chain)

    if item_selection == len(attack_chain):
        return

    attack_chain.remove(attack_chain[item_selection])
    return


def import_data():
    global args

    # TODO
    import_strs = ["OSPF LSU/LSA", "BGP Confs"]


    import_selection = SelectionMenu.get_selection(import_strs)

    if import_selection == 0:
        filename = file_selector(conf_base_path + '/ospf')
        args = import_ospf_lsa(filename, args)
    elif import_selection == 0:
        filename = file_selector(conf_base_path + '/bgp')
        args = import_bgp_confs(filename, args)
    return

def showFunctionHelp():
    #TODO
    pass


def main():

    # Parse Args
    parser()

    # Initial Setup
    setupVars()    

    # Main Menu
    logging.debug("Building menu...")
    main_menu = ConsoleMenu("Main Menu", "")

    # Show current chain option
    show_chain_opt = FunctionItem("Show Current Chain", showChain)

    # Add attack submenu
    chain_submenu = FunctionItem("Add Function", addItemToChain)

    # Remove chain item
    remove_item = FunctionItem("Remove Function", removeFromChain)

    # Function Help menu
    function_help = FunctionItem("Function Help", showFunctionHelp)

    # Select Interface
    select_int_submenu = FunctionItem("Select interface",selectInterface)

    # Run Chain
    run_chain_opt = FunctionItem("Run Chain", runChain)

    # Import data
    imports_opt = FunctionItem("Import Data", import_data)

    
    main_menu.append_item(show_chain_opt)
    main_menu.append_item(chain_submenu)
    main_menu.append_item(remove_item)
    main_menu.append_item(run_chain_opt)
    main_menu.append_item(imports_opt)
    main_menu.append_item(select_int_submenu)

    logging.debug("Finished building menu")
    logging.debug("Initialization complete")

    main_menu.show()

    logging.debug("Shutting down...")
    return

if __name__ == '__main__':
    main()


