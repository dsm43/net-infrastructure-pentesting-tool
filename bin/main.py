import argparse
import netifaces
import importlib.util
import functools
import operator
from consolemenu import *
from consolemenu.items import *
from pathlib import Path
import sys
from inspect import getmembers, isfunction

#Constants/Vars

descString = 'A python network pentesting tool'
confFilePath=''
attack_list = []
attack_chain = []
attacks_categories = []
attacks_layers = []
attacks_types = []
module_list = []
module_names = []
module_path = Path("d:\\duart\\Documents\\GitHub\\net-infrastructure-pentesting-tool\\bin\\modules")

def setupVars():

    #TODO setup importing settings from .yml  or .json file

    # List all modules to import
    module_path_list = list(module_path.glob("**/*.py"))

    # Import all modules
    for f in module_path_list:
        f_name = str(f).rstrip(".py").replace("/",".").replace("\\",".")
        spec = importlib.util.spec_from_file_location(f_name, str(f))
        module = importlib.util.module_from_spec(spec)
        sys.modules[f_name] = module
        module_names.append(f_name)
        spec.loader.exec_module(module)
        module_list.append(module)

    # Function list
    global attack_list 
    for m in module_list:
        attack_list.append(getmembers(m, isfunction))
    attack_list = functools.reduce(operator.iconcat, attack_list)
    attack_list = list(filter(lambda x: x[1].__module__ in module_names and x[0][0] != "_", attack_list))

    # Parse unique parameters from functions
    global attacks_categories
    global attacks_layers
    global attacks_types
    attacks_categories = list(set([f[1].category for f in attack_list]))
    attacks_layers = list(set([f[1].layer for f in attack_list]))

    attacks_types = dict()
    s = set([(f[1].category, f[1].type) for f in attack_list])
    for t in s:
        if t[0] not in attacks_types.keys():
            attacks_types[t[0]] = [t[1]]
        else:
            attacks_types[t[0]].append(t[1])
    return


def showChain():
    for a in attack_chain:
        print(a)
    input("Press any key to continue...")
    return

def listInterfaces():
    return netifaces.interfaces()

def listAttacksAsString():
    return list([f.__name__ for f in attack_list])

def runChain():

    #TODO verify chain integrity

    for action in attack_chain:
        if action[1].category == "middleware":
            if action[1].type == "periodic":
                pass
            elif action[1].type == "single use":
                pass
            elif action[1].type == "wrapper":
                pass
            pass
        elif action[1].category == "attack":
            if action[1].type == "MitM":
                pass
            elif action[1].type == "DoS":
                pass
            pass
        else:
            print("Unknown item category")

    pass

def parser():

    # Create the argument parser
    parser = argparse.ArgumentParser(description=descString)

    # Add arguments to the parser
    # Config file
    parser.add_argument('--conf-file', action='store')

    # Verbose configuration
    parser.add_argument('--verbose', '-v', action='count', default = 0, help='configure verbose level')

    # List available interfaces and exit
    parser.add_argument('--list-interfaces', action='store-true', help='list available interfaces and exit')

    # Create subparser for headless and normal modes
    subparsers = parser.add_subparsers(help='sub-command help')

    # Normal mode parser
    normal_parser = subparsers.add_parser('cli', help='cli help')

    # Headless mode parser
    headless_parser = subparsers.add_parser('headless', help='headless help')

    # Function choice
    headless_parser.add_argument('--attack', '-a', choices=attack_list)

    # Interface choice
    headless_parser.add_argument('--interface', '-i', choices=listInterfaces(), help='select interface to utilize')

    # Arg list for each attack
    headless_parser.add_argument('args', nargs='+', help="additional arguments for the selected attack")

    ns = parser.parse_args()

    if ns['list-interfaces'] == True:
        print(listInterfaces())
        exit(0)

def addItemToChain():

    # Select Category, i.e: middlewares, attacks
    category_selection = SelectionMenu.get_selection(attacks_categories)

    if category_selection == len(attacks_categories):
        return

    # Select layer
    layer_selection = SelectionMenu.get_selection(attacks_layers)

    if layer_selection == len(attacks_layers):
        return

    # Select type, i.e: MitM, DoS, ...
    type_selection = SelectionMenu.get_selection(attacks_types[attacks_categories[category_selection]])

    if type_selection == len(attacks_types[attacks_categories[category_selection]]):
        return

    # Filter attacks list based on selection
    atk_lst = list(filter(lambda x: x[1].layer == attacks_layers[layer_selection] and \
                                    x[1].type == attacks_types[attacks_categories[category_selection]][type_selection] and \
                                    x[1].category == attacks_categories[category_selection], attack_list))

    function_selection = SelectionMenu.get_selection(list([f[1].name for f in atk_lst]))

    if function_selection == len(atk_lst):
        return

    # Append function to current chain
    # TODO Verify if selection is valid
    attack_chain.append(atk_lst[function_selection])
    return   

def main():

    setupVars()

    # Main Menu
    main_menu = ConsoleMenu("Main Menu", "")

    # Show current chain option
    show_chain_opt = FunctionItem("Show Current Chain", showChain)

    # Add attack submenu
    chain_submenu = FunctionItem("Chain Items", addItemToChain)

    # TODO Remove chain item
    # TODO Select network interface(s)
    select_int_submenu = SelectionMenu(listInterfaces())
    # TODO Run attack

    run_chain_opt = FunctionItem("Run Chain", runChain)

    
    main_menu.append_item(show_chain_opt)
    main_menu.append_item(chain_submenu)
    main_menu.append_item(run_chain_opt)
    main_menu.append_item(select_int_submenu)

    main_menu.show()



    

    return







if __name__ == '__main__':
    main()


