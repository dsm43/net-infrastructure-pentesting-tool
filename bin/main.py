import argparse
import netifaces
import importlib.util
import functools
import operator
from consolemenu import *
from consolemenu.items import *
from pathlib import Path
import sys
from os import getcwd
from inspect import getmembers, isfunction
from libs.import_funcs import import_ospf_lsa
from libs.aux_funcs import file_selector

#Constants/Vars

descString = 'A python network pentesting tool'
confFilePath=''
attack_list = []
attack_chain = []
attacks_categories = []
attacks_layers = []
attacks_types = []
module_list = []
module_names = []
module_path = Path(getcwd()+"/bin/modules")
conf_base_path = getcwd() + '/bin/conf-examples'
attack_interface = ''
args = {}

def setupVars():

    #TODO setup importing settings from .yml  or .json file

    # List all modules to import
    module_path_list = list(module_path.glob("**/*.py"))

    # Import all modules
    for f in module_path_list:
        f_name = str(f).rstrip(".py").replace("/",".").replace("\\",".")
        spec = importlib.util.spec_from_file_location(f_name, str(f))
        module = importlib.util.module_from_spec(spec)
        sys.modules[f_name] = module
        module_names.append(f_name)
        spec.loader.exec_module(module)
        module_list.append(module)

    # Function list
    global attack_list 
    for m in module_list:
        attack_list.append(getmembers(m, isfunction))
    attack_list = functools.reduce(operator.iconcat, attack_list)
    attack_list = list(filter(lambda x: x[1].__module__ in module_names and x[0][0] != "_", attack_list))

    # Parse unique parameters from functions
    global attacks_categories
    global attacks_layers
    global attacks_types
    attacks_categories = list(set([f[1].category for f in attack_list]))
    attacks_layers = list(set([f[1].layer for f in attack_list]))

    attacks_types = dict()
    s = set([(f[1].category, f[1].type) for f in attack_list])
    for t in s:
        if t[0] not in attacks_types.keys():
            attacks_types[t[0]] = [t[1]]
        else:
            attacks_types[t[0]].append(t[1])
    return


def showChain():
    for a in attack_chain:
        print(a)
    input("Press any key to continue...")
    return

def listInterfaces():
    return netifaces.interfaces()

def selectInterface():
    global args

    iface_lst = listInterfaces()

    iface_sel = SelectionMenu.get_selection(iface_lst)

    args['iface'] = iface_lst[iface_sel]

def listAttacksAsString():
    return list([f.__name__ for f in attack_list])

def runChain():

    #TODO verify chain integrity

    global args

    for action in attack_chain:

        # Get parameters
        params = action[1].arg_list
        for param in params:
            if param not in args.keys():
                args[param] = input("Value for " + param + " >>> ")

        if action[1].category == "middleware":
            if action[1].type == "periodic":
                # TODO add thread with timer for function
                pass
            elif action[1].type == "single use":
                # Execute the function
                action[1](args)
            elif action[1].type == "wrapper":
                # Execute function and update args
                args = action[1](args)
        elif action[1].category in ("attack", "Attack"):
            # TODO send the packet
            if action[1].type == "MitM":
                action[1](args)
            elif action[1].type == "DoS":
                action[1](args)
            elif action[1].type == "Route Poisoning":
                action[1](args)
            pass
        else:
            print("Unknown item category")

    pass

def parser():

    # Create the argument parser
    parser = argparse.ArgumentParser(description=descString)

    # Add arguments to the parser
    # Debug/testing mode
    parser.add_argument('--test','-t', action='store-true', help="Run in test mode, with reduced timeouts and verbose output")
    
    
    # Config file
    #parser.add_argument('--conf-file', action='store')

    # Verbose configuration
    #parser.add_argument('--verbose', '-v', action='count', default = 0, help='configure verbose level')

    # List available interfaces and exit
    parser.add_argument('--list-interfaces', action='store-true', help='list available interfaces and exit')

    # Create subparser for headless and normal modes
    #subparsers = parser.add_subparsers(help='sub-command help')

    # Normal mode parser
    #normal_parser = subparsers.add_parser('cli', help='cli help')

    # Headless mode parser
    #headless_parser = subparsers.add_parser('headless', help='headless help')

    # Function choice
    #headless_parser.add_argument('--attack', '-a', choices=attack_list)

    # Interface choice
    #headless_parser.add_argument('--interface', '-i', choices=listInterfaces(), help='select interface to utilize')

    # Arg list for each attack
    #headless_parser.add_argument('args', nargs='+', help="additional arguments for the selected attack")

    ns = parser.parse_args()

    if ns['list-interfaces'] == True:
        print(listInterfaces())
        exit(0)

    global TEST
    TEST = False

    if ns['test'] == True:
        print("Running in test mode...")
        TEST = True

def addItemToChain():

    # Select Category, i.e: middlewares, attacks
    category_selection = SelectionMenu.get_selection(attacks_categories)

    if category_selection == len(attacks_categories):
        return

    # Select layer
    layer_selection = SelectionMenu.get_selection(attacks_layers)

    if layer_selection == len(attacks_layers):
        return

    # Select type, i.e: MitM, DoS, ...
    type_selection = SelectionMenu.get_selection(attacks_types[attacks_categories[category_selection]])

    if type_selection == len(attacks_types[attacks_categories[category_selection]]):
        return

    # Filter attacks list based on selection
    atk_lst = list(filter(lambda x: x[1].layer == attacks_layers[layer_selection] and \
                                    x[1].type == attacks_types[attacks_categories[category_selection]][type_selection] and \
                                    x[1].category == attacks_categories[category_selection], attack_list))

    function_selection = SelectionMenu.get_selection(list([f[1].name for f in atk_lst]))

    if function_selection == len(atk_lst):
        return

    # Append function to current chain
    # TODO Verify if selection is valid
    attack_chain.append(atk_lst[function_selection])
    return   

def import_data():
    global args

    # TODO
    import_strs = ["OSPF LSU/LSA"]

    import_selection = SelectionMenu.get_selection(import_strs)

    if import_selection == 0:
        filename = file_selector(conf_base_path)
        args = import_ospf_lsa(filename, args)
    return



def main():

    # Parse Args
    parser()

    # Initial Setup
    setupVars()    

    # Main Menu
    main_menu = ConsoleMenu("Main Menu", "")

    # Show current chain option
    show_chain_opt = FunctionItem("Show Current Chain", showChain)

    # Add attack submenu
    chain_submenu = FunctionItem("Chain Items", addItemToChain)

    # TODO Remove chain item
    # TODO Function Help menu
    select_int_submenu = FunctionItem("Select interface",selectInterface)

    run_chain_opt = FunctionItem("Run Chain", runChain)

    # Import data
    imports_opt = FunctionItem("Import Data", import_data)

    
    main_menu.append_item(show_chain_opt)
    main_menu.append_item(chain_submenu)
    main_menu.append_item(run_chain_opt)
    main_menu.append_item(imports_opt)
    main_menu.append_item(select_int_submenu)

    main_menu.show()

    return







if __name__ == '__main__':
    main()


