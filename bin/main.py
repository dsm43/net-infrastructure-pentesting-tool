###################################################################
#   main.py
#   Author: Duarte Matias
#   Last modified: 29/09/2022
###################################################################

# Imports
import argparse
from itertools import chain
import time
import netifaces
import importlib.util
import functools
import operator
from consolemenu import *
from consolemenu.items import *
from pathlib import Path
import sys
from os import getcwd
from inspect import getmembers, isfunction
from libs.import_funcs import import_confs
from libs.aux_funcs import file_selector, attack_cat, attack_layer, attack_type, EXIT_SIGNAL
import logging

#Constants/Vars
descString = 'A python network pentesting tool'
confFilePath=''
attack_list = []
attack_chain = []
attacks_categories = []
attacks_layers = []
attacks_types = []
module_list = []
module_names = []
module_path = Path(getcwd()+"/bin/modules")
conf_base_path = getcwd() + '/bin/conf-examples'
attack_interface = ''
args = {}


##############
#   setupVars()
#   Configures initial variable values, logging and module imports
# ############ 
def setupVars():
    # Configure Log file
    logging.basicConfig(filename=getcwd()+'/bin/debug.log', filemode='a', level=logging.DEBUG)
    logging.debug("Initalizing...")

    # List all modules to import
    module_path_list = list(module_path.glob("**/*.py"))
    logging.debug("Module listing finished")

    # Import all modules
    logging.debug("Starting module import")
    for f in module_path_list:
        # Format the module name from the module path, remove '.py' extention and replace '/' and '\\' with '.'
        f_name = str(f).removesuffix(".py").replace("/",".").replace("\\",".")

        # Utilize importlib to perform the importing
        spec = importlib.util.spec_from_file_location(f_name, str(f))
        module = importlib.util.module_from_spec(spec)

        # Add imported module to program's global module list and to global variable with imported names
        sys.modules[f_name] = module
        module_names.append(f_name)

        # Finalize loading
        spec.loader.exec_module(module)
        module_list.append(module)
        logging.debug(f"Successfully loaded module: {f_name}")

    logging.debug("Finished loading modules")

    # Function listing
    logging.debug("Listing available functions")
    global attack_list 

    # Add imported functions to the function list
    for m in module_list:
        attack_list.append(getmembers(m, isfunction))
    
    # Flatten the function list
    attack_list = functools.reduce(operator.iconcat, attack_list)

    # Remove auxiliary funtions (start with '_') or function imports in the loaded modules (not in module_names)
    attack_list = list(filter(lambda x: x[1].__module__ in module_names and x[0][0] != "_", attack_list))
    logging.debug("Function listing complete")
    logging.debug("Finished variable intialization")

    return

##############
#   showChain()
#   Prints functions in the chain
# ############ 
def showChain():
    for a in attack_chain:
        print(a[0])
    input("Press any key to continue...")
    return

##############
#   listInterfaces()
#   Lists network interfaces in the system
# ############ 
def listInterfaces():
    return netifaces.interfaces()


##############
#   selectInterface()
#   Prompts the user to select an interface from the available choices
# ############ 
def selectInterface():
    global args
    # Get interface list
    iface_lst = listInterfaces()
    # Prompt the user with a menu
    iface_sel = SelectionMenu.get_selection(iface_lst)
    # Assign interface value to the args keyword 'iface'
    args['iface'] = iface_lst[iface_sel]

def listAttacksAsString():
    return list([f.__name__ for f in attack_list])

##############
#   runChain()
#   Runs the current chain, prompting the user for any aditional values
# ############ 
def runChain():
    global args

    args['pkt'] = None

    for action in attack_chain:
        # Get parameters
        params = action[1].arg_list
        for param in params:
            # Check if a value is not set in args
            if param not in args.keys():
                args[param] = input("Value for " + param + " >>> ")

        # Run the current function
        args = action[1](args)
    
    return



##############
#   parser()
#   Defines a CLI parser to allow parsing of command line arguments 
# ############ 
def parseArgs():
    parser = argparse.ArgumentParser(description=descString) # Create the argument parser

    # Add arguments to the parser
    parser.add_argument('--test','-t', action='store_true', help="Run in test mode, with reduced timeouts and verbose output") # Debug/testing mode
    parser.add_argument('--list_interfaces', action='store_true', help='list available interfaces and exit') # List available interfaces and exit

    # Parse arguments
    ns = parser.parse_args()

    # Check for list interfaces argument
    if ns.list_interfaces == True:
        print(listInterfaces())
        exit(0)

    global TEST
    TEST = False
    # Check for test mode argument
    if ns.test == True:
        print("Running in test mode...")
        TEST = True
    return


##############
#   selectAttack()
#   Prompts the user to select an attack. Return the user selection
# ############ 
def selectAttack():
    attacks_categories_str = [m.value for n,m in attack_cat.__members__.items()] # Select Category, i.e: middlewares, attacks
    category_selection = SelectionMenu.get_selection(attacks_categories_str)
   
    if category_selection == len(attacks_categories_str): # If user selects 'exit'
        return
    
    attacks_layers_str = [m.value for n,m in attack_layer.__members__.items()] # Select layer
    layer_selection = SelectionMenu.get_selection(attacks_layers_str)
    
    if layer_selection == len(attacks_layers_str): # If user selects 'exit'
        return
    
    attacks_types_str = [m.value for n,m in attack_type.__members__.items()] # Select type, i.e: MitM, DoS, ...
    type_selection = SelectionMenu.get_selection(attacks_types_str)
    
    if type_selection == len(attacks_types_str): # If user selects 'exit'
        return

    # Filter attacks list based on selection
    atk_lst = list(filter(lambda x: x[1].layer == attack_layer(attacks_layers_str[layer_selection]) and \
                                    x[1].type == attack_type(attacks_types_str[type_selection]) and \
                                    x[1].category == attack_cat(attacks_categories_str[category_selection]), attack_list))
    
    function_selection = SelectionMenu.get_selection(list([f[1].name for f in atk_lst])) # Prompt user to select the attack

    if function_selection == len(atk_lst): # If user selects 'exit'
        return

    return atk_lst[function_selection]


##############
#   addItemToChain()
#   Prompts the user to select an attack and add it to the chain
# ############ 
def addItemToChain():
    # Select the attack
    atk = selectAttack()

    # Append function to current chain
    attack_chain.append(atk)
    return   


##############
#   removeFromChain()
#   Removes the selected attack from the current chain
# ############ 
def removeFromChain():
    item_selection = SelectionMenu.get_selection(attack_chain) # Prompt the user to select the funciton

    if item_selection == len(attack_chain): # If user selects 'exit'
        return
    
    attack_chain.remove(attack_chain[item_selection]) # Remove the selected function
    return


##############
#   importData()
#   Prompts the user for a file and imports configuration data from it 
# ############ 
def importData():
    global args
    import_strs = ["OSPF LSU/LSA", "BGP Confs", "RIP Confs", "DNS Confs"]

    # Prompt the user for a category
    import_selection = SelectionMenu.get_selection(import_strs)

    # For OSPF
    if import_selection == 0:
        filename = file_selector(conf_base_path + '/ospf')
        if filename == None:
            return
        args = import_confs(filename, args, 'lsu_info')
    # For BGP
    elif import_selection == 1:
        filename = file_selector(conf_base_path + '/bgp')
        if filename == None:
            return
        args = import_confs(filename, args, 'bgp_info')
    # For RIP
    elif import_selection == 2:
        filename = file_selector(conf_base_path + '/rip')
        if filename == None:
            return
        args = import_confs(filename, args, 'rip_info')
    # For DNS
    elif import_selection == 3:
        filename = file_selector(conf_base_path + '/dns')
        if filename == None: return
        args = import_confs(filename, args, 'dns_hosts')
    return

##############
#   showFunctionHelp()
#   Prints function's docstring
# ############ 
def showFunctionHelp():
    atk = selectAttack()    # Select the function

    print(atk[1].__doc__)   # Print the function's docstring
    input("Press ENTER to continue...")

##############
#   main()
#   Main program loop
# ############ 
def main():
    parseArgs() # Parse Command Line Arguments
    setupVars() # Initial Setup

    # Main Menu
    logging.debug("Building menu...")
    main_menu = ConsoleMenu("Main Menu", "")

    # Create submenus    
    show_chain_opt = FunctionItem("Show Current Chain", showChain) # Show current chain option
    chain_submenu = FunctionItem("Add Function", addItemToChain) # Add attack submenu    
    remove_item = FunctionItem("Remove Function", removeFromChain) # Remove chain item
    function_help = FunctionItem("Function Help", showFunctionHelp) # Function Help menu
    select_int_submenu = FunctionItem("Select interface",selectInterface) # Select Interface
    run_chain_opt = FunctionItem("Run Chain", runChain) # Run Chain
    imports_opt = FunctionItem("Import Data", importData) # Import data

    # Add submenus to the main menu
    main_menu.append_item(show_chain_opt)
    main_menu.append_item(chain_submenu)
    main_menu.append_item(remove_item)
    main_menu.append_item(run_chain_opt)
    main_menu.append_item(imports_opt)
    main_menu.append_item(select_int_submenu)
    main_menu.append_item(function_help)

    logging.debug("Finished building menu")
    logging.debug("Initialization complete")

    # Show menu to the user
    try:
        main_menu.start() # Start the menu thread
        while True:
            main_menu.join(0.5) # Attempt to join in a non-blocking way
    except KeyboardInterrupt:
        EXIT_SIGNAL.set()   # Set event to stop menu thread
        print("\nReceived KeyboardInterrupt, stopping all threads...")
        time.sleep(10)  # Wait for threads to cleanup
        main_menu.join(5)   # Attempt join
    logging.debug("Shutting down...")
    return

if __name__ == '__main__':
    main()


